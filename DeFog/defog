#!/bin/bash

#########################################################################################################################
# CSC4006 - Research And Development Project
# Developed by: Jonathan McChesney (MEng Computer Games Development)
# Queen's University Belfast
#
# Component: defog.sh
#
# How to run: sh defog .
#
# How to view help: sh defog -?
#
# Purpose: This component handles user input, as well as sourcing the configuration file. This script presents the user
#			with a series of on screen options which the user can interact with using numeric input to select the necessary
#			parameters for the deployment pipeline, TPI environment variables and fog application to benchmark. This script
#			also displays the Help and FAQ section. The defogexecute.sh script is invoked and sourced by this component.
#			This allows the defogexecute.sh script access to the configuration file and user input variables.
#
#########################################################################################################################

# link local address to the config file - UPDATE condig.sh LOCATION
source /Users/Yousef/Documents/configs/config.sh

# create local variables of config variables - Make sure to UPDATE the location of the configs
cloudaddress=$cloudaddress
clouduser=$clouduser

edgeaddress1=$edgeaddress1
edgeaddress2=$edgeaddress2
edgeaddress3=$edgeaddress3
edgeaddress4=$edgeaddress4

#edgeaddress5=$edgeaddress5
#edgeaddress6=$edgeaddress6
#edgeaddress7=$edgeaddress7
#edgeaddress8=$edgeaddress8

edgeuser1=$edgeuser1
edgeuser2=$edgeuser2
edgeuser3=$edgeuser3
edgeuser4=$edgeuser4

#edgeuser5=$edgeuser5
#edgeuser6=$edgeuser6
#edgeuser7=$edgeuser7
#edgeuser8=$edgeuser8


awskey=$awskey
cloudpublicip=$cloudpublicip

configslocation=/Users/Yousef/Documents/configs/*
configfilelocation=/Users/Yousef/Documents/config.sh

users=5
ramp_up=0
test_duration=300

################################################################################
# help function that displays commandline help to the user
function HELP {
    cat <<HELP
	Question 1: What is DeFog?

	Answer 1: DeFog is a benchmarking method that builds and runs containerised fog
	applications on the Edge and the Cloud. DeFog also allows for system
	benchmarks to be generated.

	Question 2: What is the difference between the Edge and the Cloud.

	Answer 2: The Edge is a more versatile system than the Cloud, that makes use of
	Edge nodes such as routers and swithces that have a limited availability
	of hardware but are geographically closer to end user devices such as
	laptops and smartphones than the Cloud.

HELP
}

################################################################################
# utility function to determine the edge device address (i.e. ipaddress) NOT based on user input
# BUT based on curret situation of the devices:

# added by Yousef
function edgeaddress_selector_modified {
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do
			echo ""
			echo -e "How would you like to select EDGE node device:"
				echo "Randomly    - Enter 1"
				echo "Dynamically - Enter 2"
				echo "Manually    - Enter 3"
				echo ""
		  read -p "Enter [1,2,3]: " ANS
		  case $ANS in
			'1')
			   random_selector
			   break;;
			'2')
			   dynamic_selector
			   break;;
			'3')
				 manual_selector
				 break;;
			*)
			   echo "Wrong input, try again";;
		  esac
		done
	fi
}

################################################################################
#utlity function to offload the workload to a random node device
#added by Yousef
function random_selector {

	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do

			Range=4     #to limit the range of devices; Now we only run 3 edge devices; increase the number to be equal to the number of edge deivces you run
			random_number=$RANDOM
			let "random_number %= $Range"
			echo ""
			echo "The Random device $random_number"
			echo ""

			#edge_device = random_number
			edge_device=$random_number

			case $edge_device in
			'0')
				 edgeaddress=$edgeaddress1
				 edgeuser=$edgeuser1
				 break;;
			'1')
				 edgeaddress=$edgeaddress2
				 edgeuser=$edgeuser2
				 break;;
			'2')
				 edgeaddress=$edgeaddress3
				 edgeuser=$edgeuser3
				 break;;
			'3')
				edgeaddress=$edgeaddress4
				edgeuser=$edgeuser4
				break;;
      '4')
  			edgeaddress=$edgeaddress5
  			edgeuser=$edgeuser5
  			break;;
      '5')
    		edgeaddress=$edgeaddress6
    		edgeuser=$edgeuser6
    		break;;
      '6')
        edgeaddress=$edgeaddress7
        edgeuser=$edgeuser7
        break;;
      '7')
        edgeaddress=$edgeaddress8
        edgeuser=$edgeuser8
        break;;
			*)
				 echo "Wrong input, try again";;
			esac
		done
	fi
  echo ""
	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
#utlity function to remotely read loadaverages of edge nodes,
#and forwared the workload to a device that has the minimum loadaverage
function dynamic_selector {
  while true; do
    echo ""
    echo -e "what parameters would you like to consider:"
      echo "loadavarage     - Enter 1"
      echo "latency         - Enter 2"
      echo "Memory          - Enter 3"
      echo "CPU Hardware    - Enter 4"
      echo "Decision-making - Enter 5"
      echo ""
    read -p "Enter [1,2,3,4,5]: " ANS
    case $ANS in
    '1')
       nodes_loadavg
       break;;
    '2')
       nodes_latency
       break;;
    '3')
       nodes_memory
       break;;
    '4')
       nodes_specification
       break;;
    '5')
       decision-making
       break;;
    *)
       echo "Wrong input, try again";;
    esac
  done
}

################################################################################

function nodes_loadavg {
  edgeaddress=$(cat /Users/Yousef/Desktop/Dreich_v1/DeFog/dm/cpu.txt)
  edgeuser=pi
  echo $edgeaddress
}

# utility function to manually determine the edge device based on deceion making alogrithm
function nodes_memory {
  edgeaddress=$(cat /Users/Yousef/Desktop/Dreich_v1/DeFog/dm/memory.txt)
  edgeuser=pi
  echo $edgeaddress
}

# utility function to manually determine the edge device based on deceion making alogrithm
declare -i device_counter=0
function decision-making {
  #echo "Decision Making:"
  edgeaddress=${new_edge_devices[$device_counter]}
  edgeuser=$edgeuser1
  device_counter=$((device_counter+1));
  echo $device_counter
}

################################################################################
# utility function to manually determine the edge device address (i.e. ipaddress) based on user input
function manual_selector {
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do
			echo ""
			echo -e "Please select edge node device:"
				echo "To choose Raspberry Pi 224, Enter 1"
				echo "To choose Raspberry Pi 168, Enter 2"
				echo "To choose Raspberry Pi 182, Enter 3"
        echo "To choose Raspberry Pi 131, Enter 4"
        echo "To choose Raspberry Pi 222, Enter 5"
        echo "To choose Raspberry Pi 229, Enter 6"
        echo "To choose Raspberry Pi 148, Enter 7"
        echo "To choose Raspberry Pi 230, Enter 8"
				echo ""
		  read -p "What device would you like to run: [1-8]" ANS
		  case $ANS in
			'1')
			   edgeaddress=$edgeaddress1
			   edgeuser=$edgeuser1
			   break;;
			'2')
			   edgeaddress=$edgeaddress2
			   edgeuser=$edgeuser2
			   break;;
			'3')
				 edgeaddress=$edgeaddress3
				 edgeuser=$edgeuser3
				 break;;
      '4')
   			edgeaddress=$edgeaddress4
   			edgeuser=$edgeuser4
   			break;;
      '5')
        edgeaddress=$edgeaddress5
        edgeuser=$edgeuser5
        break;;
      '6')
        edgeaddress=$edgeaddress6
        edgeuser=$edgeuser6
        break;;
      '7')
        edgeaddress=$edgeaddress7
        edgeuser=$edgeuser7
        break;;
      '8')
        edgeaddress=$edgeaddress8
        edgeuser=$edgeuser8
        break;;
			*)
			   echo "Wrong input, try again";;
		  esac
		done
	fi
	echo ""
	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
# utility function to determine the platform actions to be perfomed based on user input
function actions_user_input {
while true; do
	echo "Actions:"
		echo "0. Run DeFog Platform Benchmarks"
		echo "1. Run DeFog, Sysbench & UnixBench Platform Benchmarks"
		echo "2. Run Network Benchmark"
		echo "3. Run I/O Benchmark"
		echo "4. Run Sysbench"
		echo "5. Run UnixBench"
		echo "6. Remove Docker Containers & DeFog Architecture"
		echo "7. None"
		echo ""
  read -p "What benchmark would you like to run:[0,1,2,3,4,5,6,7] " ANS
  case $ANS in
	'0')
       actions="-g"
	   break;;
    '1')
       actions="-a"
       break;;
    '2')
       actions="-d"
       break;;
	'3')
       actions="-f"
       break;;
	'4')
       actions="-s"
       break;;
    '5')
       actions="-u"
       break;;
	'6')
       actions="-x"
	   break;;
	'7')
       actions="-n"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform pipeline based on user input
function env_user_input {
while true; do
	echo ""
	echo "Environments:"
		echo "0. Cloud Only"
		echo "1. Edge Only"
		echo "2. Cloud & Edge"
		echo ""
  read -p "What environment would you like to benchmark: [0,1,2] " ANS
  case $ANS in
    '0')
       environment="-c"
       break;;
    '1')
       environment="-e"
       break;;
	  '2')
       environment="-b"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform applications to be benchmarked based on user input
function applications_user_input {
while true; do
	echo ""
	echo -e "Fog Applications:"
		echo "0. Yolo"
		echo "1. PocketSphinx"
		echo "2. Aeneas"
		echo "3. iPokeMon (build and run)"
		echo "4. iPokeMon (run benchmarks only)"
		echo "5. FogLAMP"
		echo "6. None"
		echo ""
  read -p "What Applications would you like to benchmark: [0,1,2,3,4,5,6] " ANS
  case $ANS in
    '0')
       applications="-y"
       break;;
    '1')
       applications="-p"
       break;;
	'2')
       applications="-j"
       break;;
	'3')
       applications="-i"
       break;;
	'4')
       applications="-k"
       break;;
	'5')
       applications="-l"
       break;;
	'6')
       applications="-m"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform applications to be benchmarked
# on the cloud/edge pipeline based on user input
function applications_cloud_edge_user_input {
while true; do
	echo -e
	echo -e "Fog Applications:"
		echo ""
		echo "0. Yolo"
		echo "1. PocketSphinx"
		echo "2. Aeneas"
		echo "3. None"
		echo ""
  read -p "What Applications would you like to benchmark: [0,1,2,3] " ANS
  case $ANS in
    '0')
       applications="-y"
       break;;
    '1')
       applications="-p"
       break;;
	'2')
       applications="-j"
       break;;
	'3')
       applications="-m"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_users_user_input {
while true; do
	echo -e
	echo -e "Please select the number of users to simulate:"
		echo ""
		echo "0. 1"
		echo "1. 2"
		echo "2. Default (5)"
		echo "3. 10"
		echo "4. 25"
		echo "5. 50"
		echo "6. 100"
		echo "7. 250"
		echo ""
  read -p "How many users/threads would you like to start: [0,1,2,3,4,5,6,7] " ANS
  case $ANS in
    '0')
       users=1
       break;;
    '1')
       users=2
       break;;
	'2')
       users=5
       break;;
	'3')
       users=10
       break;;
	'4')
       users=25
       break;;
	'5')
       users=50
       break;;
	'6')
       users=100
       break;;
	'7')
       users=250
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_duration_user_input {
while true; do
	echo -e
	echo -e "Please select the test duration in seconds:"
		echo ""
		echo "0. 60"
		echo "1. 120"
		echo "2. Default (300)"
		echo "3. 600"
		echo "4. 900"
		echo ""
  read -p "How long would you like to run the test: [0,1,2,3,4] " ANS
  case $ANS in
    '0')
       test_duration=60
       break;;
    '1')
       test_duration=120
       break;;
	'2')
       test_duration=300
       break;;
	'3')
       test_duration=600
       break;;
	'4')
       test_duration=900
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_ramp_up_user_input {
while true; do
	echo -e
	echo -e "Please select the test ramp up period in seconds:"
		echo ""
		echo "0. Default (0)"
		echo "1. 10"
		echo "2. 30"
		echo "3. 60"
		echo "4. 120"
		echo ""
  read -p "How long would you like to ramp up the threads/users for: [0,1,2,3,4] " ANS
  case $ANS in
    '0')
       ramp_up=0
       break;;
    '1')
       ramp_up=10
       break;;
	'2')
       ramp_up=30
       break;;
	'3')
       ramp_up=60
       break;;
	'4')
       ramp_up=120
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to print sepeartor/formatter line
function seperator {
echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
}

################################################################################
# print and display the ascii header
function display_ascii_header {

	echo "  ___      ___            _ ";
	echo " |   \ ___| __|__  __ _  (_)";
	echo " | |) / -_) _/ _ \/ _\` |  _ ";
	echo " |___/\___|_|\___/\__, | (_)";
	echo "                  |___/     ";
	echo ""
	echo -e "DeFog: " | tee $verbose_filename.txt
	echo -e "	Demystifying Fog Systems Interaction via Container based benchmarking." | tee $verbose_filename.txt
	echo -e "	Created by: Jonathan McChesney, student at Queen's University Belfast" | tee -a $verbose_filename.txt
	echo -e "	CSC4006 Final Year Research and Development Project" | tee -a $verbose_filename.txt
	echo -e "" | tee -a $verbose_filename.txt
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
	echo -e "" | tee -a $verbose_filename.txt
}

################################################################################
# create the various results file/filenames (data file, verbose data file, jmeter file, taurus file)
function create_result_files {
	verbose_filename=result
	metrics_verbose_filename=metrics
	jmeter_filename=jmeter
	taurus_filename=taurus
	filenumber=""

	cd results
	if [[ -e $verbose_filename.txt ]] ; then
		i=0
		while [[ -e $verbose_filename-$i.txt ]] ; do
			let i++
		done
		filenumber=$i
		verbose_filename=$verbose_filename-$i
	fi
	if [[ -e $metrics_verbose_filename.txt ]] ; then
		i=0
		while [[ -e $metrics_verbose_filename-$i.txt ]] ; do
			let i++
		done
		filenumber=$i
		metrics_verbose_filename=$metrics_verbose_filename-$i
	fi
	if [[ -e $jmeter_filename.csv ]] ; then
		i=0
		while [[ -e $jmeter_filename-$i.csv ]] ; do
			let i++
		done
		filenumber=$i
		jmeter_filename=$jmeter_filename-$i
	fi
	if [[ -e $taurus_filename.csv ]] ; then
		i=0
		while [[ -e $taurus_filename-$i.csv ]] ; do
			let i++
		done
		filenumber=$i
		taurus_filename=$taurus_filename-$i
	fi
	cd ../
}

################################################################################
function setup_jmeter {

	if [ "$applications" == "-i" ] || [ "$applications" == "-k" ];
	then
		test_users_user_input
		test_duration_user_input
		test_ramp_up_user_input
	fi
}

################################################################################
function display_help {
	eval get_help=$1

	if [ "$get_help" == "-?" ] || [ "$applications" == "-h" ];
	then
		HELP
		exit 2
	fi
}

################################################################################
################################################################################
################################################################################
#########################################################################################################################
# CSC4006 - Research And Development Project
# Developed by: Jonathan McChesney (MEng Computer Games Development)
# Queen's University Belfast
#
# Component: defogexecute.sh
#
# Purpose: This script uses Secure Shell and Secure Copy Protocol to execute the actions.sh and applications.sh scripts
#			on the Cloud and Edge instances. This component also handles the calculation of metrics such as the return
#			trip time, real time factor and the full computation/communication latency time. Finally this component
#			also parses the return data and metrics and outputs the calculated metrics to the terminal and relevant
#			results files. This script passes the actions.sh and applications.sh to the Edge or Cloud instance.
#
#########################################################################################################################

# function to invoke Help and FAQ command line output
function executebenchmarkhelp {
		./defogexecute -?
}

#########################################################################################################################
# function to invoke the actions script on the cloud-edge pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters.
function benchmark_both_actions {
		# Use secure shell to navigate to the Cloud instance, using an identity file (awskey) username and cloud ec2 address.
		# The actions.sh script is supplied to the Cloud during the tunnelling porcess. This script is passed the actions and application inputs (sourced from defog.sh)
		echo -e "ssh into edge/cloud - cloud instance for actions and system benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./actions -z $actions $applications # environment variable is set to a different value for remote invocation
		echo -e "DONE - cloud ssh session"
		echo -e

		# Use secure shell to navigate to the Edge instance, using a username and edge node device address.
		# The actions.sh script is supplied to the Edge during the tunnelling porcess. This script is passed the actions and application inputs (sourced from defog.sh)
		echo -e "ssh into edge instance for actions and system benchmarks.."
		ssh $edgeuser@$edgeaddress ' sudo bash -s' -- < ./actions $environment $actions $applications
		echo -e "DONE - edge ssh session"
		echo -e
}

#########################################################################################################################
# function to invoke the application bash file on the cloud-edge pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters. The results are then transferred back from the edge as necessary.
function benchmark_both_applications {
		echo -e "ssh into edge/cloud - cloud instance for applications benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./applications -z $actions $applications
		echo -e "DONE - cloud ssh session"
		echo -e

		echo -e "ssh into edge/cloud instance for applications benchmarks.."
		ssh $edgeuser@$edgeaddress ' sudo bash -s' -- < ./applications $environment $actions $applications
		echo -e "DONE - edge ssh session"
		echo -e

		# calculate the time taken to transfer data (i.e. resutlts and data files from the edge to the local user device
		local start=$(gdate +%s.%N) #date +%s
		local transfer_cloud=$(scp -v $edgeuser@$edgeaddress:~/defog/results/* ./ 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )

		# set the transfer time, bytes transfered down and bytes per second down and set to the relevant metric index
		metricsValues[3]=$runtime
		metricsValues[8]=${newarr1[1]}
		metricsValues[11]=$(bc <<< "scale=10;${metricsValues[8]}/${metricsValues[3]}")

		# rename verbose results file, remove old file
		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		rm cloudresult.txt 2>/dev/null

		# read in results data file, save to array, remove old file
		read -a newarr < arrresult.txt
		rm arrresult.txt 2>/dev/null

		# print and save data to file
		echo -e Total bytes transferred from the edge: ${metricsValues[8]} bytes | tee -a $verbose_filename.txt
		echo Transfer both pipeline edge application results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo Transfer rate from the edge: ${metricsValues[11]} bytes per second | tee -a $verbose_filename.txt

		# invoke the set_returned_application_metrics function to set data metrics to global array
		set_returned_application_metrics

		# calculate the bytes per second down from the cloud to the edge and save to array
		metricsValues[12]=$(bc <<< "scale=10;${metricsValues[9]}/${metricsValues[13]}")
		echo "" | tee -a $verbose_filename.txt
}

#########################################################################################################################
# function to invoke the actions script on the edge only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters.
function benchmark_edge_actions {
		echo -e "ssh into edge instance for actions and system benchmarks.."
		ssh $edgeuser@$edgeaddress ' sudo bash -s' -- < ./actions $environment $actions $applications
		echo -e "DONE - edge ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		scp $edgeuser@$edgeaddress:~/defog/results/* ./
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )

		cat edgeresult.txt >> $verbose_filename.txt 2>/dev/null
		rm edgeresult.txt 2>/dev/null

		echo -e Transfer edge action results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# function to invoke the application bash file on the edge only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters. The results are then transferred back from the edge as necessary.
function benchmark_edge_applications {

    #invoke the secure copy protocol asset function
    echo -e "Sending asset at path: " $asset "to application... on" $edgeaddress
    scp_asset
    echo -e "DONE - transferring asset payload to destination"

    #containerName="darknet$1"
    #containerName="psphinx$1"
    #echo $containerName

    if [ "$applications" == "-y" ]; then containerName="darknet$1";    #added by Yousef
  elif [ "$applications" == "-p" ]; then containerName="psphinx$1";  #added by Yousef
elif [ "$applications" == "-j" ]; then containerName="aeneas$1";  #added by Yousef
    fi

    echo -e "ssh into edge instance for application benchmarks.."
		ssh	$edgeuser@$edgeaddress ' sudo bash -s' -- < ./applications $environment $actions $applications $containerName
		echo -e "DONE - edge ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		local transfer_cloud=$(scp -v $edgeuser@$edgeaddress:~/defog/results/* ./ 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )
		metricsValues[3]=$runtime
		metricsValues[8]=${newarr1[1]}
		metricsValues[11]=$(bc <<< "scale=10;${metricsValues[8]}/${metricsValues[3]}")

		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		#rm cloudresult.txt 2>/dev/null

		read -a newarr < arrresult.txt
		#rm arrresult.txt 2>/dev/null

		echo -e Total bytes transferred from the edge: ${metricsValues[8]} bytes | tee -a $verbose_filename.txt
		echo Transfer edge application results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo Transfer rate from the edge: ${metricsValues[11]} bytes per second | tee -a $verbose_filename.txt

		set_returned_application_metrics

		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# function to invoke the actions script on the cloud only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters.
function benchmark_cloud_actions {
		echo -e "ssh into cloud instance for actions and system benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./actions $environment $actions $applications
		echo -e "DONE - cloud ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		scp -i $awskey $clouduser@$cloudaddress:~/defog/results/* ./
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )

		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		rm cloudresult.txt 2>/dev/null

		echo -e Transfer cloud action results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# function to invoke the application bash file on the cloud only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters. The results are then transferred back from the edge as necessary.
function benchmark_cloud_applications {

    # invoke the secure copy protocol asset function
    echo -e "Sending asset at path: " $asset "to application..."
    scp_asset
    echo -e "DONE - transferring asset payload to destination"

    if [ "$applications" == "-y" ]; then containerName="darknet$1";    #added by Yousef
  elif [ "$applications" == "-p" ]; then containerName="psphinx$1";  #added by Yousef
elif [ "$applications" == "-j" ]; then containerName="aeneas$1";  #added by Yousef
    fi

		echo -e "ssh into cloud instance for application benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./applications $environment $actions $applications $containerName
		echo -e "DONE - cloud ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		local transfer_cloud=$(scp -v -i $awskey $clouduser@$cloudaddress:~/defog/results/* ./ 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )
		metricsValues[3]=$runtime
		metricsValues[8]=${newarr1[1]}
		metricsValues[11]=$(bc <<< "scale=10;${metricsValues[8]}/${metricsValues[3]}")

		#rm returnedasset.* 2>/dev/null

		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		#rm cloudresult.txt 2>/dev/null

		read -a newarr < arrresult.txt
		#rm arrresult.txt 2>/dev/null

		echo -e Total bytes transferred from the cloud: ${metricsValues[8]} bytes | tee -a $verbose_filename.txt
		echo Transfer cloud application results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo Transfer rate from the cloud: ${metricsValues[11]} bytes per second | tee -a $verbose_filename.txt

		set_returned_application_metrics

		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# calculate the cost of running the benchmarks on the cloud, using AWS pricing strategy
function calc_cloud_cost {

	# initialise local variables: hourly cost of computation on AWS, convertor scalar value, cost per second and compute time.
	local awshrcost=0.016
	local convert=3600
	local awsseccost=$(bc <<< "scale=10;$awshrcost/$convert") # scale=10 sets the number of decimal places to 10
	local minruntime=60
	local computetime=${metricsValues[1]}

	# deterime the cost of running on AWS using the bc utility package
	local cost=$(bc <<< "$computetime*$awsseccost")

	# update the metric array
	metricsValues[6]=$cost

	# output the results to file and the terminal using tee
	echo -e "Cloud cost for application computation (£0.016 per hour)": £$cost | tee -a $verbose_filename.txt

}

#########################################################################################################################
# Estimage the cost of running the benchmarks on the edge using a cheaper AWS pricing strategy (50% of AWS cost)
function calc_edge_cost {

	# initialise the local variables - Estimated cost based upon AWS pricing strategy
	local edgehrcost=0.008
	local convert=3600
	local edgeseccost=$(bc <<< "scale=10;$edgehrcost/$convert") # scale=10 sets the number of decimal places to 10
	local computetime=${metricsValues[1]}

	# deterime the cost of running on AWS using the bc utility package
	local cost=$(bc <<< "$computetime*$edgeseccost")

	# update the metric array
	metricsValues[6]=$cost

	# output the results to file and the terminal using tee
	echo -e "Edge cost for application computation (estimated £0.008 per hour)": £$cost | tee -a $verbose_filename.txt

}

#########################################################################################################################
# calculate the return trip time and communication latency metrics
function calc_rtt {

	local T1=${metricsValues[0]}
	local E=${metricsValues[1]}
	local T3=${metricsValues[3]}

	if  [ "${metricsValues[13]}" == "NA" ];
	then
		local T4=0
	else
		local T4=${metricsValues[13]}
	fi

	local cl=$(bc <<< "$T1+$T3") # communication latency
	local rtt=$(bc <<< "$T1+$T3+$E") # round trip time
	local fcl=$(bc <<< "$T1+$T3+$T4") # communication latency
	local frtt=$(bc <<< "$T1+$T3+$E+$T4") # round trip time

	metricsValues[4]=$rtt # time to transfer data to and from cloud/edge as well as computation time
	metricsValues[14]=$cl # time to transfer data to and from cloud/edge
	metricsValues[15]=$frtt # time to transfer data to and from cloud/edge as well as computation time
	metricsValues[16]=$fcl # time to transfer data to and from cloud/edge

	echo -e Round Trip Time: $rtt secs | tee -a $verbose_filename.txt

}

#########################################################################################################################
# calculate real time factor for audio applications (computational time / length of audio file in seconds)
function calc_rtf {
	local computation=${newarr[1]}
	local length=${newarr[5]}
	local rtf=$(bc <<< "scale=10;$computation/$length")

	metricsValues[5]=$rtf

	echo Real Time Factor: $rtf secs | tee -a $verbose_filename.txt
}

#########################################################################################################################
# iterate over metrics returned from the edge or cloud, set them to local array
function set_returned_application_metrics {
	local mets=${#metricsValues[@]}
	local count=1

	if [ "${newarr[10]}" != "NA" ];
	then
		metricsValues[13]=${newarr[10]} # set time taken to transfer data from the cloud to the edge
	fi

	for (( i=0; i<=$(( $mets -1 )); i++ ))
	do
		((count++))

		if [ "${metricsValues[$i]}" == "NA" ] && [ "${newarr[$i]}" != "NA" ] && [ "${newarr[$i]}" ];
		then
			metricsValues[$i]=${newarr[$i]} # set retured data to local array
		fi
	done

}

#########################################################################################################################
# utility function to update the current pipeline text based on the input sourced from the defog.sh script
function set_pipeline {
		# initialise to default value
		pipeline="NA"

		# set the pipeline variable name to the current pipeline/platform selected, sourced from defog.sh
		if [ "$environment" == "-c" ]; then pipeline="Cloud-Only";
		elif [ "$environment" == "-e" ]; then pipeline="Edge-Only";
		elif [ "$environment" == "-b" ]; then pipeline="Cloud/Edge";
		fi
}

#########################################################################################################################
# invoke the relevant application benchmark utility function
function benchmark_applications {

		set_pipeline
		# print application header to verbose file and invoke application benchmarks
		if [ "$applications" == "-y" ];
		then
			echo YOLO Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_fog_app "arrPics" "./assets/yolo-assets/yoloimage.jpg" "./assets/yolo-assets/*.jpg" "YOLO"

		elif [ "$applications" == "-p" ];
		then
			echo Pocket Sphinx Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_fog_app "arrWavs" "./assets/psphinx-assets/psphinx.wav" "./assets/psphinx-assets/*.wav" "PocketSphinx"

		elif [ "$applications" == "-j" ];
		then
			echo Aeneas Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_aeneas

		elif [ "$applications" == "-i" ];
		then
			echo iPokeMon Benchmarks: | tee -a $verbose_filename.txt
			seperator
			start_ipokemon_server
			benchmark_ipokemon

		elif [ "$applications" == "-k" ];
		then
			echo iPokeMon Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_ipokemon

		elif [ "$applications" == "-l" ];
		then
			echo FogLAMP Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_fog_app "arrCurlCommands" "./assets/foglamp-assets/foglampcurlcommand.sh" "./assets/foglamp-assets/*.sh" "FogLAMP"
		fi
}

#########################################################################################################################
# benchmark iPokemon server using a jmx file to simulate user behaviour
function benchmark_ipokemon {
	# navigate to jmeter bin folder
	cd jmeter/bin

	# initialise the local asset variables
	local ipokemon_jmx=../../assets/ipokemon-assets/iPokemon.jmx
	local host=''

	if [ "$environment" == "-c" ];
	then
		host=$cloudpublicip # if cloud
	else
		host=$edgeaddress # if edge
	fi

	# run jmeter using user defined variables (automation of jsx file - allows execution on the edge or cloud)
	echo "Running JMeter..."
	./jmeter -n -t $ipokemon_jmx -JHOST=$host -JDuration=$test_duration -JThreads=$users -JRamp=$ramp_up -l testresults.csv

	# run tautus using user defined variables (automation of jmeter jsx file) and using reporting.yaml as a parameter
	echo "Running Taurus..."
	bzt $ipokemon_jmx -o modules.jmeter.properties.HOST=$host -o modules.jmeter.properties.Duration=$test_duration -o modules.jmeter.properties.Threads=$users -o modules.jmeter.properties.Ramp=$ramp_up reporting.yaml

	# move and rename test data files to the results file, redirect output using 2>/dev/null
	mv testresults.csv ../../results/$jmeter_filename.csv 2>/dev/null
	mv taurusreport.csv ../../results/$taurus_filename.csv 2>/dev/null
	mv taurusreport.xml ../../results/$taurus_filename.xml 2>/dev/null

	# navigate to defog folder
	cd ../../
}

#########################################################################################################################
# setup and start the iPokeMon server
function start_ipokemon_server {
		# determine the platform/pipeline secure shell tunnel (ssh) into, and enter the iPokeMon docker container (use ctrl p & ctrl q to detach the container)
		if [ "$environment" == "-c" ] || [ "$environment" == "-b" ];
		then
			ssh -i $awskey $clouduser@$cloudaddress -t "cd defog/ipokemonbuild/iPokeMon/docker && sudo -sH && . enter.sh; bash"
		fi
		if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
		then
			ssh $edgeuser@$edgeaddress -t "cd defog/ipokemonbuild/iPokeMon/docker && sudo -sH && . enter.sh; bash"
		fi
}

#########################################################################################################################
# determine the pipeline/platform to benchmark the applications on, invoke the calculation of real time trip and real time factor variables
function benchmark_application {
		echo -e
		if [ "$environment" == "-c" ]; # cloud only
		then
			benchmark_cloud_applications $1
			calc_rtt
			if [ "${metricsValues[5]}" != "NA" ];
			then
				calc_rtf
			fi
			calc_cloud_cost
		fi
		if [ "$environment" == "-e" ]; # edge only
		then
			#benchmark_edge_applications
      benchmark_edge_applications $1  #$1 = count
      calc_rtt
			if [ "${metricsValues[5]}" != "NA" ];
			then
				calc_rtf
			fi
			calc_edge_cost
		fi
		if [ "$environment" == "-b" ]; # cloud/edge
		then
			benchmark_both_applications
			calc_rtt
			if [ "${metricsValues[5]}" != "NA" ];
			then
				calc_rtf
			fi
			calc_edge_cost
		fi
		echo -e
		echo -e "DeFog Metrics:"
		echo -e ${metricsValues[@]} | tee -a $metrics_verbose_filename.txt
}

#########################################################################################################################
# benchmark fog application - accepts asset array name, asset name, asset path and application name as parameters.
function benchmark_fog_app {

	# evaluate paramaters and initialise variables # benchmark_fog_app "arrPics" "./assets/yolo-assets/yoloimage.jpg" "./assets/yolo-assets/*.jpg" "YOLO"
	eval array_name="$1"                          # arrPics
	eval new_asset_name="$2"                      # ./assets/yolo-assets/yoloimage.jpg
	eval asset_path="$3"                          # ./assets/yolo-assets/*.jpg
	eval application_name="$4"                    # YOLO

	# declare asset array, asset name and counter
	declare -a $array_name
	newassetname=$new_asset_name
	local count=1

  # to return assingment from decision-making function
  declare -a new_edge_devices=$(python /Users/Yousef/Desktop/Dreich_v1/DeFog/dm/mipj.py)

  # iterate over all assets in an asset folder
  local num_files=${#new_edge_devices[@]}
  echo "number of files found=" $num_files

  for file in $asset_path
	do
    sleep 3
    if [ "$applications" == "-y" ]; then newassetname="darknet$count.jpg";    #added by Yousef
    elif [ "$applications" == "-p" ]; then newassetname="psphinx$count.wav";    #added by Yousef
    fi
    #newassetname="darknet$count.jpg"

    # reset/create the metric array
		create_metric_array

		# Output to the terminal and results file using tee
		echo -e "" | tee -a $verbose_filename.txt
		echo $application_name Benchmark Run $count: | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

		# update array and asset variables for the current iteration
		array_name=("${assets_name[@]}" "$file")
		asset=$array_name

    # select edge node based on different resource allocations
    #manual_selector                              # to select edge node manually
    #random_selector                              # to select edge node randomly
    nodes_loadavg                                # to select edge node min loadavg
    #nodes_memory                                 # to select edge node max memory
    #decision-making                              # to select edge node based on OR-function


    if [ "$environment" == "-c" ]; then metricsValues[19]=$cloudaddress; #added by Yousef
    elif [ "$environment" == "-e" ]; then metricsValues[19]=$edgeaddress;  #added by Yousef
    fi

    # Update the pipeline and application metric values
    metricsValues[17]=$pipeline
    metricsValues[18]=$application_name
    metricsValues[21]=$newassetname

    if [ "$edgeaddress" == "192.168.1.131" ]; then metricsValues[20]="RPi4B"; #added by Yousef
    elif [ "$edgeaddress" == "192.168.1.182" ]; then metricsValues[20]="RPi3B+";  #added by Yousef
    elif [ "$edgeaddress" == "192.168.1.148" ]; then metricsValues[20]="RPi3B";
    elif [ "$edgeaddress" == "192.168.1.224" ]; then metricsValues[20]="RPi2B";
    fi

    #benchmark_edge_actions
    #transfer_config "1"

		# invoke the secure copy protocol asset function
		#echo -e "Sending asset at path: " $asset "to application..."
		#scp_asset
		#echo -e "DONE - transferring asset payload to destination"

		# invoke the benchmark_application function
    #benchmark_application $count

    benchmark_application $count &     # & to fork muiltple processes, $count to pass image number as a parameter
    #if (($count%num_files==0));
    if (($count%32==0));
    then
    wait
    fi
		# increment counter
		((count++))

	done
}

#########################################################################################################################
function benchmark_aeneas {

  # to return assingment from decision-making function
  declare -a new_edge_devices=$(python /Users/Yousef/Desktop/Dreich_v1/DeFog/dm/mipj.py)
  #echo $new_edge_devices

  # iterate over all assets in an asset folder
  local num_files=${#new_edge_devices[@]}
  echo "number of files found=" $num_files

  #metricsValues[19]=$edgeaddress #added by Yousef to read ip address of the edge device
  if [ "$environment" == "-c" ]; then metricsValues[19]=$cloudaddress; #added by Yousef
  elif [ "$environment" == "-e" ]; then metricsValues[19]=$edgeaddress;  #added by Yousef
  fi
  # Update the pipeline and application metric values
  metricsValues[17]=$pipeline
  metricsValues[18]=$application_name
  metricsValues[21]=$newassetname

  if [ "$edgeaddress" == "192.168.1.131" ]; then metricsValues[20]="RPi4B"; #added by Yousef
elif [ "$edgeaddress" == "192.168.1.182" ]; then metricsValues[20]="RPi3B+";  #added by Yousef
elif [ "$edgeaddress" == "192.168.1.148" ]; then metricsValues[20]="RPi3B";
elif [ "$edgeaddress" == "192.168.1.224" ]; then metricsValues[20]="RPi2B";
  fi

  #benchmark_edge_actions
  #transfer_config "1"

	declare -a arrAudios

	for file1 in ./assets/aeneas-assets/audio/*.mp3
	do
		arrAudios=("${arrAudios[@]}" "$file1")
	done

	declare -a arrTexts

	for file2 in ./assets/aeneas-assets/text/*.xhtml
	do
		local arrTexts=("${arrTexts[@]}" "$file2")
	done

	total=${#arrAudios[@]}

	local count=1

	for (( j=0; j<=$(( $total -1 )); j++ ))
	do
    sleep 3

		multiassets="true"
		create_metric_array

    # select edge node based on different functions
    #manual_selector                              # to select edge node manually
    #random_selector                               # to select edge node randomly
    nodes_loadavg                                # to select edge node min loadavg
    #nodes_memory                                 # to select edge node max memory
    #decision-making                             # to select edge node based on decision-making function

    #edgeaddress=$edgeaddress1  #some function to retun Ip address of the device
    #edgeuser=$edgeuser1

		metricsValues[17]=$pipeline
		metricsValues[18]="Aeneas"
    if [ "$environment" == "-c" ]; then metricsValues[19]=$cloudaddress; #added by Yousef
    elif [ "$environment" == "-e" ]; then metricsValues[19]=$edgeaddress;  #added by Yousef
    fi
    metricsValues[21]="aeneas$count"

    if [ "$edgeaddress" == "192.168.1.131" ]; then metricsValues[20]="Pi4B"; #added by Yousef
    elif [ "$edgeaddress" == "192.168.1.182" ]; then metricsValues[20]="Pi3B+";  #added by Yousef
    elif [ "$edgeaddress" == "192.168.1.148" ]; then metricsValues[20]="Pi3B";
    elif [ "$edgeaddress" == "192.168.1.224" ]; then metricsValues[20]="Pi2B";
    fi

		echo -e "" | tee -a $verbose_filename.txt
		echo Aeneas Benchmark Run $count: | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

		asset=${arrAudios[$j]}
		newassetname=./assets/aeneas-assets/aeneasaudio.mp3


		echo "Sending asset at path: " $asset "to application..."
		scp_asset
		echo "DONE"

		local oldT1=${metricsValues[0]}
		local oldbu1=${metricsValues[7]}

		metricsValues[0]=$oldT1
		metricsValues[7]=$oldbu1

		asset=${arrTexts[$j]}
		newassetname=./assets/aeneas-assets/aeneastext.xhtml

		# if [ "$environment" != "-b" ];
		# then
		# 	echo -e "Sending asset at path: " $asset "to application..."
		# 	scp_asset
		# 	echo "DONE"
		# fi

		# if [ "$environment" == "-b" ];
		# then
		# 	local shortasset="${asset##*/}"
		# 	echo $shortasset > ./aeneas.txt
    #
		# 	asset=./aeneas.txt
		# 	newassetname=./aeneas.txt
    #
		# 	echo -e "Sending asset at path: " $asset "to application..."
		# 	scp_asset
		# 	echo "DONE"
		# fi

		#benchmark_application

		#((count++))

    benchmark_application $count &     # & to fork muiltple processes, $count to pass image number as a parameter
    #if (($count%num_files==0));
    if (($count%32==0));
    then
    wait
    fi
    # increment counter
    ((count++))

	done

}

#########################################################################################################################
# instantiate or reset metric labels and values to default values
function create_metric_array {
	declare -g metricsLabels=('T1' 'ET' 'S3' 'T3' 'RTT' 'RTF' 'Cost' 'BytesUp1' 'BytesDown1' 'BytesDown2' 'BytesPerSecUp1' 'BytesPerSecDown1' 'BytesPerSecDown2' 'T4' 'CL' 'FRTT' 'FCL' 'Pipeline' 'Application' 'Device' 'EdgeNode' 'imageName')
	declare -g metricsValues=('NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA')
}

#########################################################################################################################
# secure copy/transfer data/assets to destination platform
function scp_asset {
	TIMEFORMAT=%R # set time format
	cp $asset $newassetname       #copy sourcefile destinationfile
	local start=$(gdate +%s.%N) # start timer to calculat ethe time it takes to transfer data

	# transfer data to the cloud and set array metrics to local variable
	if [ "$environment" == "-c" ]; # cloud only
	then
		local transfer_cloud=$(scp -v -i $awskey $newassetname $clouduser@$cloudaddress:~/defog/assets 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
	fi

	# transfer data to the edge and set array metrics to local variable
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ]; # edge only or cloud/edge
	then
		local transfer_edge=$(scp -v $newassetname $edgeuser@$edgeaddress:~/defog/assets 2>&1 | grep "Transferred")
		local newval=${transfer_edge//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
	fi

	# determine the time taken to transfer data
	local end=$(gdate +%s.%N)
	local runtime=$( echo "$end - $start" | bc -l )

	# if running an application that sends multiple assets - sum the bytes sent and time taken to transfer the assets
	if [ "$multiassets" == "true" ] && [ "${metricsValues[0]}" != "NA" ];
	then
		metricsValues[0]=$(bc <<< "${metricsValues[0]}+$runtime")
		metricsValues[7]=$(bc <<< "${metricsValues[7]}+${newarr1[0]}")
		local bytesUpVar=$(bc <<< "scale=10;${metricsValues[7]}/${metricsValues[0]}")
		metricsValues[10]=$(bc <<< "$bytesUpVar")
	else
		metricsValues[0]=$runtime
		metricsValues[7]=${newarr1[0]}
		metricsValues[10]=$(bc <<< "scale=10;${metricsValues[7]}/${metricsValues[0]}")
	fi

	# remove duplicate asset
	rm $newassetname 2>/dev/null

}

#########################################################################################################################
# transfer the configuration file securely to the cloud or the edge using secure copy protocol. The destination platform is passed in as a paramater. Redirect the console output using 2>&1.
function transfer_config {
	# evaluate the destination platform id parameter
	eval config_destination="$1"

	if [ "$config_destination" == "1" ] || [ "$config_destination" == "2" ]; then # if edge or cloud/edge
		echo -e "Transferring configuration files to the Edge:"
			#scp $configslocation $edgeuser@$edgeaddress:~/defog/configs > /dev/null 2>&1
			scp $configslocation $edgeuser@$edgeaddress:~/defog/configs 2>&1
	fi
	if [ "$config_destination" == "0" ] || [ "$config_destination" == "2" ]; then # if cloud or cloud/edge
		echo -e "Transferring configuration files to the Cloud:"
			scp -i $awskey $configslocation $clouduser@$cloudaddress:~/defog/configs 2>&1
	fi
	echo -e "DONE - Transferring configuration files"
	echo -e
}

#########################################################################################################################
# utility function to print verbose sepeartor/formatter line to file using tee
function seperator {
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
}

################################################################################
################################################################################
################################################################################
################################################################################

#The appalication start here:

# to remove old results and assets
ssh pi@192.168.1.224 sudo bash /home/pi/defog/setup.sh
ssh pi@192.168.1.168 sudo bash /home/pi/defog/setup.sh
ssh pi@192.168.1.182 sudo bash /home/pi/defog/setup.sh
ssh pi@192.168.1.131 sudo bash /home/pi/defog/setup.sh

ssh pi@192.168.1.222 sudo bash /home/pi/defog/setup.sh
ssh pi@192.168.1.229 sudo bash /home/pi/defog/setup.sh
ssh pi@192.168.1.230 sudo bash /home/pi/defog/setup.sh
ssh pi@192.168.1.148 sudo bash /home/pi/defog/setup.sh
#ssh -i "/Users/Yousef/Documents/configs/EC2.pem" ubuntu@ec2-3-87-222-15.compute-1.amazonaws.com sudo bash /home/ubuntu/defog/setup.sh


create_result_files
#profiling_nodes
#display_ascii_header
#display_help $1
applications_user_input  # choose application first then choose the deployment environment (Cloud / edge)
env_user_input
if [ "$environment" == "-c" ]; # cloud only
then
  # to remove old results and assets
  ssh -i "/Users/Yousef/Documents/configs/EC2.pem" ubuntu@ec2-3-87-222-15.compute-1.amazonaws.com sudo bash /home/ubuntu/defog/setup.sh
  echo ""
  echo -e "Cloud Only Benchmarks: " | tee -a $verbose_filename.txt
  seperator
  echo "" | tee -a $verbose_filename.txt
  setup_jmeter
fi

if [ "$environment" == "-e" ]; # edge only #some changes on edge environment by Yousef
then
  echo ""
  echo -e "Edge Only Benchmarks: " | tee -a $verbose_filename.txt
  seperator
  echo "" | tee -a $verbose_filename.txt
  setup_jmeter
fi

if [ "$environment" == "-b" ]; # cloud/edge
then
  echo ""
  echo -e "Edge/Cloud Benchmarks: " | tee -a $verbose_filename.txt
  seperator
  echo "" | tee -a $verbose_filename.txt
  manual_selector
  actions="-n"
  applications_cloud_edge_user_input
fi

echo -e
(
    export actions
    export environment
    export applications
    export users
    export ramp_up
    export test_duration
    export filenumber
    export verbose_filename
    export metrics_verbose_filename
    export jmeter_filename
    export taurus_filename
    export cloudaddress
    export clouduser
    export edgeaddress
    export edgeaddress1
    export edgeaddress2
    export edgeuser
    export edgeuser1
    export edgeuser2
    export awskey
    export cloudpublicip
    export configslocation
    export configfilelocation

    #(source ./defogexecute)  # I merge defog file and defogexecute

)
################################################################################
################################################################################
################################################################################
# main functionality - invoke the create_metric_array function, output the metric labels to the result file. Determine the pipeline to run based on input sourced from the defog.sh script.
# transfer the config file to the Edge r Cloud and run the action or application functions. Cat and command line utility tr -s is used to parse and format the results data to a csv output file.
# The output files are then moved to the results folder

function main {

	# invoke the creation of the metric array
	create_metric_array
  start_time_for_all_tasks=$(gdate +%s.%N)  #added by Yousef. This to start compute processing time of all tasks over all nodes

	# output the lavels to the results file
	echo ${metricsLabels[@]} >> $metrics_verbose_filename.txt

	# handle the pipeline specific actions/application benchmarks
	if [ "$environment" == "-c" ]; # cloud only
	then
		#benchmark_cloud_actions
		#transfer_config "0"
		benchmark_applications
	fi

	if [ "$environment" == "-e" ]; # edge only
	then
		#benchmark_edge_actions
		#transfer_config "1"
		benchmark_applications
	fi

	if [ "$environment" == "-b" ]; # cloud/edge
	then
		benchmark_both_actions
		transfer_config "2"
		benchmark_applications
	fi

	# parase and format the captured metric data and output to a csv file. Using the correct naming convention variable. The output is redirected to remove unnecessary terminal output
	cat $metrics_verbose_filename.txt | tr -s '[:blank:]' ',' > $metrics_verbose_filename.csv 2>/dev/null

	# move the results files to the results output and redirect terminal std:: output
	mv $verbose_filename.txt results/ 2>/dev/null
	mv $metrics_verbose_filename.txt results/ 2>/dev/null
	mv $metrics_verbose_filename.csv results/ 2>/dev/null
	rm results.txt 2>/dev/null

  end_time_for_all_tasks=$(gdate +%s.%N)  #added by Yousef

  Time_to_run_all_tasks=$( echo "$end_time_for_all_tasks - $start_time_for_all_tasks" | bc -l )
  echo start_time=$start_time_for_all_tasks
  echo end_time=$end_time_for_all_tasks
  echo Time to complete all tasks=$Time_to_run_all_tasks sec
}

main

################################################################################
################################################################################
################################################################################
# expect user input for displaying helphelp
while getopts :h: opt; do
    case "$opt" in
        h)
            HELP
            ;;
        ?)
            HELP
            ;;
    esac
done
