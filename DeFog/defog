#!/bin/bash

#########################################################################################################################
# CSC4006 - Research And Development Project
# Developed by: Jonathan McChesney (MEng Computer Games Development)
# Queen's University Belfast
#
# Component: defog.sh
#
# How to run: sh defog .
#
# How to view help: sh defog -?
#
# Purpose: This component handles user input, as well as sourcing the configuration file. This script presents the user
#			with a series of on screen options which the user can interact with using numeric input to select the necessary
#			parameters for the deployment pipeline, TPI environment variables and fog application to benchmark. This script
#			also displays the Help and FAQ section. The defogexecute.sh script is invoked and sourced by this component.
#			This allows the defogexecute.sh script access to the configuration file and user input variables.
#
#########################################################################################################################

# link local address to the config file - UPDATE condig.sh LOCATION
source /Users/Yousef/Documents/configs/config.sh

# create local variables of config variables - Make sure to UPDATE the location of the configs
cloudaddress=$cloudaddress
clouduser=$clouduser

edgeaddress1=$edgeaddress1
edgeaddress2=$edgeaddress2
edgeaddress3=$edgeaddress3
edgeaddress4=$edgeaddress4

edgeuser1=$edgeuser1
edgeuser2=$edgeuser2
edgeuser3=$edgeuser3
edgeuser4=$edgeuser4

awskey=$awskey
cloudpublicip=$cloudpublicip

configslocation=/Users/Yousef/Documents/configs/*
configfilelocation=/Users/Yousef/Documents/config.sh

users=5
ramp_up=0
test_duration=300

################################################################################
# help function that displays commandline help to the user
function HELP {
    cat <<HELP
	Question 1: What is DeFog?

	Answer 1: DeFog is a benchmarking method that builds and runs containerised fog
	applications on the Edge and the Cloud. DeFog also allows for system
	benchmarks to be generated.

	Question 2: What is the difference between the Edge and the Cloud.

	Answer 2: The Edge is a more versatile system than the Cloud, that makes use of
	Edge nodes such as routers and swithces that have a limited availability
	of hardware but are geographically closer to end user devices such as
	laptops and smartphones than the Cloud.

HELP
}

################################################################################
# utility function to determine the edge device address (i.e. ipaddress) NOT based on user input
# BUT based on curret situation of the devices:

# added by Yousef
function edgeaddress_selector_modified {
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do
			echo ""
			echo -e "How would you like to select EDGE node device:"
				echo "Randomly    - Enter 1"
				echo "Dynamically - Enter 2"
				echo "Manually    - Enter 3"
				echo ""
		  read -p "Enter [1,2,3]: " ANS
		  case $ANS in
			'1')
			   random_selector
			   break;;
			'2')
			   dynamic_selector
			   break;;
			'3')
				 manual_selector
				 break;;
			*)
			   echo "Wrong input, try again";;
		  esac
		done
	fi
}

################################################################################
#utlity function to offload the workload to a random node device
#added by Yousef
function random_selector {

	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do

			Range=15     #to limit the range of devices; Now we only run 3 edge devices; increase the number to be equal to the number of edge deivces you run
			random_number=$RANDOM
			let "random_number %= $Range"
			echo ""
			echo "The Random device $random_number"
			echo ""

			#edge_device = random_number
			edge_device=$random_number

			case $edge_device in
			'0')
				 edgeaddress=$edgeaddress1
				 edgeuser=$edgeuser1
				 break;;
			'1')
				 edgeaddress=$edgeaddress2
				 edgeuser=$edgeuser2
				 break;;
			'2')
				 edgeaddress=$edgeaddress3
				 edgeuser=$edgeuser3
				 break;;
			'3')
				edgeaddress=$edgeaddress4
				edgeuser=$edgeuser4
				break;;
			*)
				 echo "Wrong input, try again";;
			esac
		done
	fi
  echo ""
	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
#utlity function to remotely read loadaverages of edge nodes,
#and forwared the workload to a device that has the minimum loadaverage
function dynamic_selector {
  while true; do
    echo ""
    echo -e "what parameters would you like to consider:"
      echo "loadavarage    - Enter 1"
      echo "latency        - Enter 2"
      echo "Memory         - Enter 3"
      echo "CPU Hardware   - Enter 4"
      echo ""
    read -p "Enter [1,2,3,4]: " ANS
    case $ANS in
    '1')
       nodes_loadavg
       break;;
    '2')
       nodes_latency
       break;;
    '3')
       nodes_memory
       break;;
    '4')
       nodes_specification
       break;;
    *)
       echo "Wrong input, try again";;
    esac
  done
}

################################################################################
function nodes_loadavg {
  	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  	then
  		while true; do
  			echo ""
  		  ##########################################################################
        # remotely access edge nodes and read the current loadavarage
  			echo "Reading loadaverage of the available edge nodes:"
  			cpu_usage1=$(ssh $edgeuser1@$edgeaddress1 cat /proc/loadavg | awk '{print $1}')
  			cpu_usage2=$(ssh $edgeuser2@$edgeaddress2 cat /proc/loadavg | awk '{print $1}')
  			cpu_usage3=$(ssh $edgeuser3@$edgeaddress3 cat /proc/loadavg | awk '{print $1}')
        cpu_usage4=$(ssh $edgeuser4@$edgeaddress4 cat /proc/loadavg | awk '{print $1}')
        #cpu_usage5=$(ssh -i "myEC2.pem" $clouduser@$cloudaddress cat /proc/loadavg | awk '{print $1}')

        echo loadavarage of $edgeaddress1 is $cpu_usage1
        echo loadavarage of $edgeaddress2 is $cpu_usage2
        echo loadavarage of $edgeaddress3 is $cpu_usage3
        echo loadavarage of $edgeaddress4 is $cpu_usage4
        #echo loadavarage of $clouduser is $cpu_usage5

  			echo -e
        declare nodes_loadavarages=($cpu_usage1 $cpu_usage2 $cpu_usage3 $cpu_usage4)
        echo loadavarages of the avilable edge nodes =  ${nodes_loadavarages[*]}
  			echo -e

  			max=${nodes_loadavarages[0]}
  			min=${nodes_loadavarages[0]}
  			for i in "${nodes_loadavarages[@]}";
  			do
  				(( $(echo "$i > $max" |bc -l) )) && max=$i
  				(( $(echo "$i < $min" |bc -l) )) && min=$i
  			done
  			echo maximum loadaverage is $max
  			echo minimum loadavarage is $min

  			#to find the index of device with maximum loadavarage
  			for i in "${!nodes_loadavarages[@]}"; do
  			   if [[ "${nodes_loadavarages[$i]}" = "${max}" ]]; then
  			     device1="${i}"
  			     echo index of maximum is $device1;
  			   fi
  			done

  			#To find the index of device with minimum loadavarage
  			for i in "${!nodes_loadavarages[@]}"; do
  			   if [[ "${nodes_loadavarages[$i]}" = "${min}" ]]; then
  			     device2="${i}"
  			       echo index of minimum is $device2;
  			   fi
  			done

  			##########################################################################
  			#edge_device = the deivce that has min loadavarage
  			edge_device=$device2

  		  case $edge_device in
  			'0')
  			   edgeaddress=$edgeaddress1
  			   edgeuser=$edgeuser1
  			   break;;
  			'1')
  			   edgeaddress=$edgeaddress2
  			   edgeuser=$edgeuser2
  			   break;;
  			'2')
  				 edgeaddress=$edgeaddress3
  				 edgeuser=$edgeuser3
  				 break;;
        '3')
           edgeaddress=$edgeaddress4
           edgeuser=$edgeuser4
           break;;

  			*)
  			   echo "Wrong input, try again";;
  		  esac
  		done
  	fi
  	echo ""
  	#echo device that has the maximum workload is $
  	#echo device that has the minimum workload is $edgeaddress
  	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
function nodes_latency {
  	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  	then
  		while true; do
  			echo ""
  			########################################################################
  			# communication latency using ping
  			echo "Communication Latency to the available Edge Nodes:"
  			#communication_latency1=$(ping -c 1 $edgeaddress1)
  			#extract avg time in ping
  			node1_latency=$(ping -c 1 $edgeaddress1 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  			node2_latency=$(ping -c 1 $edgeaddress2 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  			node3_latency=$(ping -c 1 $edgeaddress3 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
        node4_latency=$(ping -c 1 $edgeaddress4 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
        #communication_latency4=$(ping -c 1 $edgeaddress4 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  			#communication_latency5=$(ping -c 1 $cloudaddress | tail -1| awk '{print $4}' | cut -d '/' -f 2)

  			echo Communciation Latency to $edgeaddress1 is $node1_latency ms
  			echo Communciation Latency to $edgeaddress2 is $node2_latency ms
  			echo Communciation Latency to $edgeaddress3 is $node3_latency ms
        echo Communciation Latency to $edgeaddress4 is $node4_latency ms
        #echo Communciation Latency to $edgeaddress4 is $communication_latency4 ms
  			#echo Communciation Latency to the Cloud-AWS is $communication_latency5 ms

  			########################################################################
  			#comapare the pings and select the deivce that has the min latency
  			echo -e
  			declare nodes_latency=($node1_latency $node2_latency $node3_latency $node4_latency)
  			echo Communication Latency of the avilable edge nodes =  ${nodes_latency[*]}
  			echo -e

  			max=${nodes_latency[0]}
  			min=${nodes_latency[0]}
  			for i in "${nodes_latency[@]}";
  			do
  				(( $(echo "$i > $max" |bc -l) )) && max=$i
  				(( $(echo "$i < $min" |bc -l) )) && min=$i
  			done
  			echo maximum nodes_latency is $max
  			echo minimum nodes_latency is $min

  			#to find the index of device with maximum latency
  			for i in "${!nodes_latency[@]}"; do
  			   if [[ "${nodes_latency[$i]}" = "${max}" ]]; then
  			     device1="${i}"
  			     echo index of maximum is $device1;
  			   fi
  			done

  			#To find the index of device with minimum latecny
  			for i in "${!nodes_latency[@]}"; do
  			   if [[ "${nodes_latency[$i]}" = "${min}" ]]; then
  			     device2="${i}"
  			       echo index of minimum is $device2;
  			   fi
  			done

  			########################################################################
  			#edge_device = the deivce that has min latency
  			edge_device=$device2

  		  case $edge_device in
  			'0')
  			   edgeaddress=$edgeaddress1
  			   edgeuser=$edgeuser1
  			   break;;
  			'1')
  			   edgeaddress=$edgeaddress2
  			   edgeuser=$edgeuser2
  			   break;;
  			'2')
  				 edgeaddress=$edgeaddress3
  				 edgeuser=$edgeuser3
  				 break;;
        '3')
           edgeaddress=$edgeaddress4
           edgeuser=$edgeuser4
           break;;

  			*)
  			   echo "Wrong input, try again";;
  		  esac
  		done
  	fi
  	echo ""
  	echo Workload will be offloaded to edge node $edgeaddress

}

################################################################################
function nodes_memory {

  if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  then
    while true; do
      echo "Reading Free Memory of available edge nodes"
      node1_mem=$(ssh $edgeuser1@$edgeaddress1 free --mega | grep Mem | awk '{print $4}')
      node2_mem=$(ssh $edgeuser2@$edgeaddress2 free --mega | grep Mem | awk '{print $4}')
      node3_mem=$(ssh $edgeuser3@$edgeaddress3 free --mega | grep Mem | awk '{print $4}')
      node4_mem=$(ssh $edgeuser4@$edgeaddress4 free --mega | grep Mem | awk '{print $4}')

      echo Free Memory of $edgeaddress1 is $node1_mem megabytes
      echo Free Memory of $edgeaddress2 is $node2_mem megabytes
      echo Free Memory of $edgeaddress3 is $node3_mem megabytes
      echo Free Memory of $edgeaddress4 is $node4_mem megabytes

  ################################################################################
  #comapare the RAM and select the deivce that has the max
     echo -e
     declare nodes_mem=($node1_mem $node2_mem $node3_mem $node4_mem)
     echo Free Memory of the avilable edge nodes =  ${nodes_mem[*]}
     echo -e

     max=${nodes_mem[0]}
     min=${nodes_mem[0]}
     for i in "${nodes_mem[@]}";
     do
       (( $(echo "$i > $max" |bc -l) )) && max=$i
       (( $(echo "$i < $min" |bc -l) )) && min=$i
     done
     echo maximum memory is $max
     echo minimum memory is $min

     #to find the index of device with maximum free memory
     for i in "${!nodes_mem[@]}"; do
       if [[ "${nodes_mem[$i]}" = "${max}" ]]; then
       device1="${i}"
       echo index of maximum is $device1;
     fi
   done

   #To find the index of device with minimum free memory
   for i in "${!nodes_mem[@]}"; do
     if [[ "${nodes_mem[$i]}" = "${min}" ]]; then
       device2="${i}"
      echo index of minimum is $device2;
     fi
   done

  ########################################################################
  #edge_device = the deivce that has max free memory
  edge_device=$device1

  case $edge_device in
  '0')
     edgeaddress=$edgeaddress1
     edgeuser=$edgeuser1
     break;;
  '1')
     edgeaddress=$edgeaddress2
     edgeuser=$edgeuser2
     break;;
  '2')
     edgeaddress=$edgeaddress3
     edgeuser=$edgeuser3
     break;;
  '3')
     edgeaddress=$edgeaddress4
     edgeuser=$edgeuser4
     break;;
  *)
     echo "Wrong input, try again";;
  esac
done
fi
echo ""
echo Workload will be offloaded to edge node $edgeaddress

}

################################################################################
function nodes_specification {

  	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  	then
  		while true; do

  			echo ""
  		  ########################################################################
        # remotely access edge devices nodes and read the hardware specifications
  			echo "Reading CPU specifications of available edge nodes:"
  			cpu_info1=$(ssh $edgeuser1@$edgeaddress1 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  			cpu_info2=$(ssh $edgeuser2@$edgeaddress2 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  			cpu_info3=$(ssh $edgeuser3@$edgeaddress3 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
        cpu_info4=$(ssh $edgeuser4@$edgeaddress4 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
        #cpu_info5=$(ssh -i "myEC2.pem" $clouduser@$cloudaddress cat /proc/cpuinfo | awk -F: '/model name/ {name=$2} END {print name}')

        echo cpuinfo of $edgeaddress1 is $cpu_info1
        echo cpuinfo of $edgeaddress2 is $cpu_info2
        echo cpuinfo of $edgeaddress3 is $cpu_info3
        echo cpuinfo of $edgeaddress4 is $cpu_info4
        #echo cpuinfo of $cloudaddress is $cpu_info5

  			##########################################################################
  			#comapare the loadavarages and select the deivce that has the min loadavarage
  			echo -e
  			declare nodes_infos=($cpu_info1 $cpu_info2 $cpu_info3 $cpu_info4)

  			max=${nodes_infos[0]}
  			min=${nodes_infos[0]}
  			for i in "${nodes_infos[@]}";
  			do
  				(( $(echo "$i > $max" |bc -l) )) && max=$i
  				(( $(echo "$i < $min" |bc -l) )) && min=$i
  			done
  			echo maximum cpu is $max
  			echo minimum cpu is $min

  			#to find the index of device with maximum value
  			for i in "${!nodes_infos[@]}"; do
  			   if [[ "${nodes_infos[$i]}" = "${max}" ]]; then
  			     device1="${i}"
  			     echo index of maximum is $device1;
  			   fi
  			done

  			#To find the index of device with minimum value
  			for i in "${!nodes_infos[@]}"; do
  			   if [[ "${nodes_infos[$i]}" = "${min}" ]]; then
  			     device2="${i}"
  			       echo index of minimum is $device2;
  			   fi
  			done

  			##########################################################################
  			#edge_device = the deivce that has max MIPS value
  			edge_device=$device1

  		  case $edge_device in
  			'0')
  			   edgeaddress=$edgeaddress1
  			   edgeuser=$edgeuser1
  			   break;;
  			'1')
  			   edgeaddress=$edgeaddress2
  			   edgeuser=$edgeuser2
  			   break;;
  			'2')
  				 edgeaddress=$edgeaddress3
  				 edgeuser=$edgeuser3
  				 break;;
        '3')
           edgeaddress=$edgeaddress4
           edgeuser=$edgeuser4
           break;;

  			*)
  			   echo "Wrong input, try again";;
  		  esac
  		done
  	fi
  	echo ""
  	echo Workload will be offloaded to edge node $edgeaddress

}
################################################################################
function profiling_nodes {
  echo
  echo "Profiling edge nodes:"
  echo
  echo "Reading loadaverage of the available edge nodes:"
  cpu_usage1=$(ssh $edgeuser1@$edgeaddress1 cat /proc/loadavg | awk '{print $1}')
  cpu_usage2=$(ssh $edgeuser2@$edgeaddress2 cat /proc/loadavg | awk '{print $1}')
  cpu_usage3=$(ssh $edgeuser3@$edgeaddress3 cat /proc/loadavg | awk '{print $1}')
  cpu_usage4=$(ssh $edgeuser4@$edgeaddress4 cat /proc/loadavg | awk '{print $1}')

  echo loadavarage of $edgeaddress1 is $cpu_usage1
  echo loadavarage of $edgeaddress2 is $cpu_usage2
  echo loadavarage of $edgeaddress3 is $cpu_usage3
  echo loadavarage of $edgeaddress4 is $cpu_usage4
  echo

  echo "Reading Communication Latency to the available Edge Nodes:"
  node1_latency=$(ping -c 1 $edgeaddress1 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  node2_latency=$(ping -c 1 $edgeaddress2 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  node3_latency=$(ping -c 1 $edgeaddress3 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  node4_latency=$(ping -c 1 $edgeaddress4 | tail -1| awk '{print $4}' | cut -d '/' -f 2)

  echo Communciation Latency to $edgeaddress1 is $node1_latency ms
  echo Communciation Latency to $edgeaddress2 is $node2_latency ms
  echo Communciation Latency to $edgeaddress3 is $node3_latency ms
  echo Communciation Latency to $edgeaddress4 is $node4_latency ms
  echo

  echo "Reading Free Memory of available edge nodes"
  node1_mem=$(ssh $edgeuser1@$edgeaddress1 free --mega | grep Mem | awk '{print $4}')
  node2_mem=$(ssh $edgeuser2@$edgeaddress2 free --mega | grep Mem | awk '{print $4}')
  node3_mem=$(ssh $edgeuser3@$edgeaddress3 free --mega | grep Mem | awk '{print $4}')
  node4_mem=$(ssh $edgeuser4@$edgeaddress4 free --mega | grep Mem | awk '{print $4}')

  echo Free Memory of $edgeaddress1 is $node1_mem megabytes
  echo Free Memory of $edgeaddress2 is $node2_mem megabytes
  echo Free Memory of $edgeaddress3 is $node3_mem megabytes
  echo Free Memory of $edgeaddress4 is $node4_mem megabytes
  echo

  echo "Reading CPU specifications of available edge nodes:"
  cpu_info1=$(ssh $edgeuser1@$edgeaddress1 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  cpu_info2=$(ssh $edgeuser2@$edgeaddress2 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  cpu_info3=$(ssh $edgeuser3@$edgeaddress3 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  cpu_info4=$(ssh $edgeuser4@$edgeaddress4 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)

  echo cpuinfo of $edgeaddress1 is $cpu_info1
  echo cpuinfo of $edgeaddress2 is $cpu_info2
  echo cpuinfo of $edgeaddress3 is $cpu_info3
  echo cpuinfo of $edgeaddress4 is $cpu_info4
  echo
}

################################################################################
# utility function to manually determine the edge device address (i.e. ipaddress) based on user input
function manual_selector {
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do
			echo ""
			echo -e "Please select edge node device:"
				echo "To choose Raspberry Pi 1, Enter 1"
				echo "To choose Raspberry Pi 2, Enter 2"
				echo "To choose Raspberry Pi 3, Enter 3"
        echo "To choose Raspberry Pi 4, Enter 4"
				echo ""
		  read -p "What device would you like to run:[1,2,3,4] " ANS
		  case $ANS in
			'1')
			   edgeaddress=$edgeaddress1
			   edgeuser=$edgeuser1
			   break;;
			'2')
			   edgeaddress=$edgeaddress2
			   edgeuser=$edgeuser2
			   break;;
			'3')
				 edgeaddress=$edgeaddress3
				 edgeuser=$edgeuser3
				 break;;
      '4')
   			edgeaddress=$edgeaddress4
   			edgeuser=$edgeuser4
   			break;;
			*)
			   echo "Wrong input, try again";;
		  esac
		done
	fi
	echo ""
	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
# utility function to determine the platform actions to be perfomed based on user input
function actions_user_input {
while true; do
	echo "Actions:"
		echo "0. Run DeFog Platform Benchmarks"
		echo "1. Run DeFog, Sysbench & UnixBench Platform Benchmarks"
		echo "2. Run Network Benchmark"
		echo "3. Run I/O Benchmark"
		echo "4. Run Sysbench"
		echo "5. Run UnixBench"
		echo "6. Remove Docker Containers & DeFog Architecture"
		echo "7. None"
		echo ""
  read -p "What benchmark would you like to run:[0,1,2,3,4,5,6,7] " ANS
  case $ANS in
	'0')
       actions="-g"
	   break;;
    '1')
       actions="-a"
       break;;
    '2')
       actions="-d"
       break;;
	'3')
       actions="-f"
       break;;
	'4')
       actions="-s"
       break;;
    '5')
       actions="-u"
       break;;
	'6')
       actions="-x"
	   break;;
	'7')
       actions="-n"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform pipeline based on user input
function env_user_input {
while true; do
	echo ""
	echo "Environments:"
		echo "0. Cloud Only"
		echo "1. Edge Only"
		echo "2. Cloud & Edge"
		echo ""
  read -p "What environment would you like to benchmark: [0,1,2] " ANS
  case $ANS in
    '0')
       environment="-c"
       break;;
    '1')
       environment="-e"
       break;;
	  '2')
       environment="-b"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform applications to be benchmarked based on user input
function applications_user_input {
while true; do
	echo ""
	echo -e "Fog Applications:"
		echo "0. Yolo"
		echo "1. PocketSphinx"
		echo "2. Aeneas"
		echo "3. iPokeMon (build and run)"
		echo "4. iPokeMon (run benchmarks only)"
		echo "5. FogLAMP"
		echo "6. None"
		echo ""
  read -p "What Applications would you like to benchmark: [0,1,2,3,4,5,6] " ANS
  case $ANS in
    '0')
       applications="-y"
       break;;
    '1')
       applications="-p"
       break;;
	'2')
       applications="-j"
       break;;
	'3')
       applications="-i"
       break;;
	'4')
       applications="-k"
       break;;
	'5')
       applications="-l"
       break;;
	'6')
       applications="-m"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform applications to be benchmarked
# on the cloud/edge pipeline based on user input
function applications_cloud_edge_user_input {
while true; do
	echo -e
	echo -e "Fog Applications:"
		echo ""
		echo "0. Yolo"
		echo "1. PocketSphinx"
		echo "2. Aeneas"
		echo "3. None"
		echo ""
  read -p "What Applications would you like to benchmark: [0,1,2,3] " ANS
  case $ANS in
    '0')
       applications="-y"
       break;;
    '1')
       applications="-p"
       break;;
	'2')
       applications="-j"
       break;;
	'3')
       applications="-m"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_users_user_input {
while true; do
	echo -e
	echo -e "Please select the number of users to simulate:"
		echo ""
		echo "0. 1"
		echo "1. 2"
		echo "2. Default (5)"
		echo "3. 10"
		echo "4. 25"
		echo "5. 50"
		echo "6. 100"
		echo "7. 250"
		echo ""
  read -p "How many users/threads would you like to start: [0,1,2,3,4,5,6,7] " ANS
  case $ANS in
    '0')
       users=1
       break;;
    '1')
       users=2
       break;;
	'2')
       users=5
       break;;
	'3')
       users=10
       break;;
	'4')
       users=25
       break;;
	'5')
       users=50
       break;;
	'6')
       users=100
       break;;
	'7')
       users=250
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_duration_user_input {
while true; do
	echo -e
	echo -e "Please select the test duration in seconds:"
		echo ""
		echo "0. 60"
		echo "1. 120"
		echo "2. Default (300)"
		echo "3. 600"
		echo "4. 900"
		echo ""
  read -p "How long would you like to run the test: [0,1,2,3,4] " ANS
  case $ANS in
    '0')
       test_duration=60
       break;;
    '1')
       test_duration=120
       break;;
	'2')
       test_duration=300
       break;;
	'3')
       test_duration=600
       break;;
	'4')
       test_duration=900
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_ramp_up_user_input {
while true; do
	echo -e
	echo -e "Please select the test ramp up period in seconds:"
		echo ""
		echo "0. Default (0)"
		echo "1. 10"
		echo "2. 30"
		echo "3. 60"
		echo "4. 120"
		echo ""
  read -p "How long would you like to ramp up the threads/users for: [0,1,2,3,4] " ANS
  case $ANS in
    '0')
       ramp_up=0
       break;;
    '1')
       ramp_up=10
       break;;
	'2')
       ramp_up=30
       break;;
	'3')
       ramp_up=60
       break;;
	'4')
       ramp_up=120
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to print sepeartor/formatter line
function seperator {
echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
}

################################################################################
# print and display the ascii header
function display_ascii_header {

	echo "  ___      ___            _ ";
	echo " |   \ ___| __|__  __ _  (_)";
	echo " | |) / -_) _/ _ \/ _\` |  _ ";
	echo " |___/\___|_|\___/\__, | (_)";
	echo "                  |___/     ";
	echo ""
	echo -e "DeFog: " | tee $verbose_filename.txt
	echo -e "	Demystifying Fog Systems Interaction via Container based benchmarking." | tee $verbose_filename.txt
	echo -e "	Created by: Jonathan McChesney, student at Queen's University Belfast" | tee -a $verbose_filename.txt
	echo -e "	CSC4006 Final Year Research and Development Project" | tee -a $verbose_filename.txt
	echo -e "" | tee -a $verbose_filename.txt
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
	echo -e "" | tee -a $verbose_filename.txt
}

################################################################################
# create the various results file/filenames (data file, verbose data file, jmeter file, taurus file)
function create_result_files {
	verbose_filename=result
	metrics_verbose_filename=metrics
	jmeter_filename=jmeter
	taurus_filename=taurus
	filenumber=""

	cd results_Yousef    #changed by Yousef.. now all results are stored in the same file.cvs file
	if [[ -e $verbose_filename.txt ]] ; then
		i=0
		while [[ -e $verbose_filename-$i.txt ]] ; do
			let i++
		done
		filenumber=$i
		verbose_filename=$verbose_filename-$i
	fi
	if [[ -e $metrics_verbose_filename.txt ]] ; then
		i=0
		while [[ -e $metrics_verbose_filename-$i.txt ]] ; do
			let i++
		done
		filenumber=$i
		metrics_verbose_filename=$metrics_verbose_filename-$i
	fi
	if [[ -e $jmeter_filename.csv ]] ; then
		i=0
		while [[ -e $jmeter_filename-$i.csv ]] ; do
			let i++
		done
		filenumber=$i
		jmeter_filename=$jmeter_filename-$i
	fi
	if [[ -e $taurus_filename.csv ]] ; then
		i=0
		while [[ -e $taurus_filename-$i.csv ]] ; do
			let i++
		done
		filenumber=$i
		taurus_filename=$taurus_filename-$i
	fi
	cd ../
}

################################################################################
function setup_jmeter {

	if [ "$applications" == "-i" ] || [ "$applications" == "-k" ];
	then
		test_users_user_input
		test_duration_user_input
		test_ramp_up_user_input
	fi
}

################################################################################
function display_help {
	eval get_help=$1

	if [ "$get_help" == "-?" ] || [ "$applications" == "-h" ];
	then
		HELP
		exit 2
	fi
}

################################################################################
################################################################################
# application main

	create_result_files
  profiling_nodes
  
  #echo "Decision Making:"
  #python /Users/Yousef/Documents/DeFog-master/DeFog/rm_cp.py
  #python /Users/Yousef/Documents/DeFog-master/DeFog/rm_mip.py
  #display_ascii_header
	#display_help $1

  applications_user_input  # choose application first then choose the deployment environment (Cloud / edge)

  env_user_input

	if [ "$environment" == "-c" ]; # cloud only
	then
		echo ""
		echo -e "Cloud Only Benchmarks: " | tee -a $verbose_filename.txt
		seperator
		echo "" | tee -a $verbose_filename.txt
		setup_jmeter
	fi

	if [ "$environment" == "-e" ]; # edge only #some changes on edge environment by Yousef
	then
		echo ""
		echo -e "Edge Only Benchmarks: " | tee -a $verbose_filename.txt
		seperator
		echo "" | tee -a $verbose_filename.txt
		edgeaddress_selector_modified  # added by Yousef
		setup_jmeter
	fi

	if [ "$environment" == "-b" ]; # cloud/edge
	then
		echo ""
		echo -e "Edge/Cloud Benchmarks: " | tee -a $verbose_filename.txt
		seperator
		echo "" | tee -a $verbose_filename.txt
		manual_selector
		actions="-n"
		applications_cloud_edge_user_input
	fi

	echo -e

	(
		export actions
		export environment
		export applications
		export users
		export ramp_up
		export test_duration
		export filenumber
		export verbose_filename
		export metrics_verbose_filename
		export jmeter_filename
		export taurus_filename
		export cloudaddress
		export clouduser
		export edgeaddress
		export edgeaddress1
		export edgeaddress2
		export edgeuser
		export edgeuser1
		export edgeuser2
		export awskey
		export cloudpublicip
		export configslocation
		export configfilelocation

		source ./defogexecute
)

################################################################################
# expect user input for displaying helphelp
while getopts :h: opt; do
    case "$opt" in
        h)
            HELP
            ;;
        ?)
            HELP
            ;;
    esac
done
