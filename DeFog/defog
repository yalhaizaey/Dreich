#!/bin/bash

#########################################################################################################################
# CSC4006 - Research And Development Project
# Developed by: Jonathan McChesney (MEng Computer Games Development)
# Queen's University Belfast
#
# Component: defog.sh
#
# How to run: sh defog .
#
# How to view help: sh defog -?
#
# Purpose: This component handles user input, as well as sourcing the configuration file. This script presents the user
#			with a series of on screen options which the user can interact with using numeric input to select the necessary
#			parameters for the deployment pipeline, TPI environment variables and fog application to benchmark. This script
#			also displays the Help and FAQ section. The defogexecute.sh script is invoked and sourced by this component.
#			This allows the defogexecute.sh script access to the configuration file and user input variables.
#
#########################################################################################################################

# link local address to the config file - UPDATE condig.sh LOCATION
source /Users/Yousef/Documents/configs/config.sh

# create local variables of config variables - Make sure to UPDATE the location of the configs
cloudaddress=$cloudaddress
clouduser=$clouduser

edgeaddress1=$edgeaddress1
edgeaddress2=$edgeaddress2
edgeaddress3=$edgeaddress3
edgeaddress4=$edgeaddress4

edgeuser1=$edgeuser1
edgeuser2=$edgeuser2
edgeuser3=$edgeuser3
edgeuser4=$edgeuser4

awskey=$awskey
cloudpublicip=$cloudpublicip

configslocation=/Users/Yousef/Documents/configs/*
configfilelocation=/Users/Yousef/Documents/config.sh

users=5
ramp_up=0
test_duration=300

################################################################################
# help function that displays commandline help to the user
function HELP {
    cat <<HELP
	Question 1: What is DeFog?

	Answer 1: DeFog is a benchmarking method that builds and runs containerised fog
	applications on the Edge and the Cloud. DeFog also allows for system
	benchmarks to be generated.

	Question 2: What is the difference between the Edge and the Cloud.

	Answer 2: The Edge is a more versatile system than the Cloud, that makes use of
	Edge nodes such as routers and swithces that have a limited availability
	of hardware but are geographically closer to end user devices such as
	laptops and smartphones than the Cloud.

HELP
}

################################################################################
# utility function to determine the edge device address (i.e. ipaddress) NOT based on user input
# BUT based on curret situation of the devices:

# added by Yousef
function edgeaddress_selector_modified {
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do
			echo ""
			echo -e "How would you like to select EDGE node device:"
				echo "Randomly    - Enter 1"
				echo "Dynamically - Enter 2"
				echo "Manually    - Enter 3"
				echo ""
		  read -p "Enter [1,2,3]: " ANS
		  case $ANS in
			'1')
			   random_selector
			   break;;
			'2')
			   dynamic_selector
			   break;;
			'3')
				 manual_selector
				 break;;
			*)
			   echo "Wrong input, try again";;
		  esac
		done
	fi
}

################################################################################
#utlity function to offload the workload to a random node device
#added by Yousef
function random_selector {

	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do

			Range=4     #to limit the range of devices; Now we only run 3 edge devices; increase the number to be equal to the number of edge deivces you run
			random_number=$RANDOM
			let "random_number %= $Range"
			echo ""
			echo "The Random device $random_number"
			echo ""

			#edge_device = random_number
			edge_device=$random_number

			case $edge_device in
			'0')
				 edgeaddress=$edgeaddress1
				 edgeuser=$edgeuser1
				 break;;
			'1')
				 edgeaddress=$edgeaddress2
				 edgeuser=$edgeuser2
				 break;;
			'2')
				 edgeaddress=$edgeaddress3
				 edgeuser=$edgeuser3
				 break;;
			'3')
				edgeaddress=$edgeaddress4
				edgeuser=$edgeuser4
				break;;
			*)
				 echo "Wrong input, try again";;
			esac
		done
	fi
  echo ""
	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
#utlity function to remotely read loadaverages of edge nodes,
#and forwared the workload to a device that has the minimum loadaverage
function dynamic_selector {
  while true; do
    echo ""
    echo -e "what parameters would you like to consider:"
      echo "loadavarage     - Enter 1"
      echo "latency         - Enter 2"
      echo "Memory          - Enter 3"
      echo "CPU Hardware    - Enter 4"
      echo "Decision-making - Enter 5"
      echo ""
    read -p "Enter [1,2,3,4,5]: " ANS
    case $ANS in
    '1')
       nodes_loadavg
       break;;
    '2')
       nodes_latency
       break;;
    '3')
       nodes_memory
       break;;
    '4')
       nodes_specification
       break;;
    '5')
       decision-making
       break;;
    *)
       echo "Wrong input, try again";;
    esac
  done
}

################################################################################
function nodes_loadavg {
  	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  	then
  		while true; do
  			echo ""
  		  ##########################################################################
        # remotely access edge nodes and read the current loadavarage
  			echo "Reading loadaverage of the available edge nodes:"
  			cpu_usage1=$(ssh $edgeuser1@$edgeaddress1 cat /proc/loadavg | awk '{print $1}')
  			cpu_usage2=$(ssh $edgeuser2@$edgeaddress2 cat /proc/loadavg | awk '{print $1}')
  			cpu_usage3=$(ssh $edgeuser3@$edgeaddress3 cat /proc/loadavg | awk '{print $1}')
        cpu_usage4=$(ssh $edgeuser4@$edgeaddress4 cat /proc/loadavg | awk '{print $1}')
        #cpu_usage5=$(ssh -i "myEC2.pem" $clouduser@$cloudaddress cat /proc/loadavg | awk '{print $1}')

        echo loadavarage of $edgeaddress1 is $cpu_usage1
        echo loadavarage of $edgeaddress2 is $cpu_usage2
        echo loadavarage of $edgeaddress3 is $cpu_usage3
        echo loadavarage of $edgeaddress4 is $cpu_usage4
        #echo loadavarage of $clouduser is $cpu_usage5

  			echo -e
        declare nodes_loadavarages=($cpu_usage1 $cpu_usage2 $cpu_usage3 $cpu_usage4)
        echo loadavarages of the avilable edge nodes =  ${nodes_loadavarages[*]}
  			echo -e

  			max=${nodes_loadavarages[0]}
  			min=${nodes_loadavarages[0]}
  			for i in "${nodes_loadavarages[@]}";
  			do
  				(( $(echo "$i > $max" |bc -l) )) && max=$i
  				(( $(echo "$i < $min" |bc -l) )) && min=$i
  			done
  			echo maximum loadaverage is $max
  			echo minimum loadavarage is $min

  			#to find the index of device with maximum loadavarage
  			for i in "${!nodes_loadavarages[@]}"; do
  			   if [[ "${nodes_loadavarages[$i]}" = "${max}" ]]; then
  			     device1="${i}"
  			     echo index of maximum is $device1;
  			   fi
  			done

  			#To find the index of device with minimum loadavarage
  			for i in "${!nodes_loadavarages[@]}"; do
  			   if [[ "${nodes_loadavarages[$i]}" = "${min}" ]]; then
  			     device2="${i}"
  			       echo index of minimum is $device2;
  			   fi
  			done

  			##########################################################################
  			#edge_device = the deivce that has min loadavarage
  			edge_device=$device2

  		  case $edge_device in
  			'0')
  			   edgeaddress=$edgeaddress1
  			   edgeuser=$edgeuser1
  			   break;;
  			'1')
  			   edgeaddress=$edgeaddress2
  			   edgeuser=$edgeuser2
  			   break;;
  			'2')
  				 edgeaddress=$edgeaddress3
  				 edgeuser=$edgeuser3
  				 break;;
        '3')
           edgeaddress=$edgeaddress4
           edgeuser=$edgeuser4
           break;;

  			*)
  			   echo "Wrong input, try again";;
  		  esac
  		done
  	fi
  	echo ""
  	#echo device that has the maximum workload is $
  	#echo device that has the minimum workload is $edgeaddress
  	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
function nodes_latency {
  	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  	then
  		while true; do
  			echo ""
  			########################################################################
  			# communication latency using ping
  			echo "Communication Latency to the available Edge Nodes:"
  			#communication_latency1=$(ping -c 1 $edgeaddress1)
  			#extract avg time in ping
  			node1_latency=$(ping -c 1 $edgeaddress1 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  			node2_latency=$(ping -c 1 $edgeaddress2 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  			node3_latency=$(ping -c 1 $edgeaddress3 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
        node4_latency=$(ping -c 1 $edgeaddress4 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
        #communication_latency4=$(ping -c 1 $edgeaddress4 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  			#communication_latency5=$(ping -c 1 $cloudaddress | tail -1| awk '{print $4}' | cut -d '/' -f 2)

  			echo Communciation Latency to $edgeaddress1 is $node1_latency ms
  			echo Communciation Latency to $edgeaddress2 is $node2_latency ms
  			echo Communciation Latency to $edgeaddress3 is $node3_latency ms
        echo Communciation Latency to $edgeaddress4 is $node4_latency ms
        #echo Communciation Latency to $edgeaddress4 is $communication_latency4 ms
  			#echo Communciation Latency to the Cloud-AWS is $communication_latency5 ms

  			########################################################################
  			#comapare the pings and select the deivce that has the min latency
  			echo -e
  			declare nodes_latency=($node1_latency $node2_latency $node3_latency $node4_latency)
  			echo Communication Latency of the avilable edge nodes =  ${nodes_latency[*]}
  			echo -e

  			max=${nodes_latency[0]}
  			min=${nodes_latency[0]}
  			for i in "${nodes_latency[@]}";
  			do
  				(( $(echo "$i > $max" |bc -l) )) && max=$i
  				(( $(echo "$i < $min" |bc -l) )) && min=$i
  			done
  			echo maximum nodes_latency is $max
  			echo minimum nodes_latency is $min

  			#to find the index of device with maximum latency
  			for i in "${!nodes_latency[@]}"; do
  			   if [[ "${nodes_latency[$i]}" = "${max}" ]]; then
  			     device1="${i}"
  			     echo index of maximum is $device1;
  			   fi
  			done

  			#To find the index of device with minimum latecny
  			for i in "${!nodes_latency[@]}"; do
  			   if [[ "${nodes_latency[$i]}" = "${min}" ]]; then
  			     device2="${i}"
  			       echo index of minimum is $device2;
  			   fi
  			done

  			########################################################################
  			#edge_device = the deivce that has min latency
  			edge_device=$device2

  		  case $edge_device in
  			'0')
  			   edgeaddress=$edgeaddress1
  			   edgeuser=$edgeuser1
  			   break;;
  			'1')
  			   edgeaddress=$edgeaddress2
  			   edgeuser=$edgeuser2
  			   break;;
  			'2')
  				 edgeaddress=$edgeaddress3
  				 edgeuser=$edgeuser3
  				 break;;
        '3')
           edgeaddress=$edgeaddress4
           edgeuser=$edgeuser4
           break;;

  			*)
  			   echo "Wrong input, try again";;
  		  esac
  		done
  	fi
  	echo ""
  	echo Workload will be offloaded to edge node $edgeaddress

}

################################################################################
function nodes_memory {

  if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  then
    while true; do
      echo "Reading Free Memory of available edge nodes"
      node1_mem=$(ssh $edgeuser1@$edgeaddress1 free --mega | grep Mem | awk '{print $4}')
      node2_mem=$(ssh $edgeuser2@$edgeaddress2 free --mega | grep Mem | awk '{print $4}')
      node3_mem=$(ssh $edgeuser3@$edgeaddress3 free --mega | grep Mem | awk '{print $4}')
      node4_mem=$(ssh $edgeuser4@$edgeaddress4 free --mega | grep Mem | awk '{print $4}')

      echo Free Memory of $edgeaddress1 is $node1_mem megabytes
      echo Free Memory of $edgeaddress2 is $node2_mem megabytes
      echo Free Memory of $edgeaddress3 is $node3_mem megabytes
      echo Free Memory of $edgeaddress4 is $node4_mem megabytes

  ################################################################################
  #comapare the RAM and select the deivce that has the max
     echo -e
     declare nodes_mem=($node1_mem $node2_mem $node3_mem $node4_mem)
     echo Free Memory of the avilable edge nodes =  ${nodes_mem[*]}
     echo -e

     max=${nodes_mem[0]}
     min=${nodes_mem[0]}
     for i in "${nodes_mem[@]}";
     do
       (( $(echo "$i > $max" |bc -l) )) && max=$i
       (( $(echo "$i < $min" |bc -l) )) && min=$i
     done
     echo maximum memory is $max
     echo minimum memory is $min

     #to find the index of device with maximum free memory
     for i in "${!nodes_mem[@]}"; do
       if [[ "${nodes_mem[$i]}" = "${max}" ]]; then
       device1="${i}"
       echo index of maximum is $device1;
     fi
   done

   #To find the index of device with minimum free memory
   for i in "${!nodes_mem[@]}"; do
     if [[ "${nodes_mem[$i]}" = "${min}" ]]; then
       device2="${i}"
      echo index of minimum is $device2;
     fi
   done

  ########################################################################
  #edge_device = the deivce that has max free memory
  edge_device=$device1

  case $edge_device in
  '0')
     edgeaddress=$edgeaddress1
     edgeuser=$edgeuser1
     break;;
  '1')
     edgeaddress=$edgeaddress2
     edgeuser=$edgeuser2
     break;;
  '2')
     edgeaddress=$edgeaddress3
     edgeuser=$edgeuser3
     break;;
  '3')
     edgeaddress=$edgeaddress4
     edgeuser=$edgeuser4
     break;;
  *)
     echo "Wrong input, try again";;
  esac
done
fi
echo ""
echo Workload will be offloaded to edge node $edgeaddress

}

################################################################################
function nodes_specification {

  	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
  	then
  		while true; do

  			echo ""
  		  ########################################################################
        # remotely access edge devices nodes and read the hardware specifications
  			echo "Reading CPU specifications of available edge nodes:"
  			cpu_info1=$(ssh $edgeuser1@$edgeaddress1 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  			cpu_info2=$(ssh $edgeuser2@$edgeaddress2 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  			cpu_info3=$(ssh $edgeuser3@$edgeaddress3 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
        cpu_info4=$(ssh $edgeuser4@$edgeaddress4 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
        #cpu_info5=$(ssh -i "myEC2.pem" $clouduser@$cloudaddress cat /proc/cpuinfo | awk -F: '/model name/ {name=$2} END {print name}')

        echo cpuinfo of $edgeaddress1 is $cpu_info1
        echo cpuinfo of $edgeaddress2 is $cpu_info2
        echo cpuinfo of $edgeaddress3 is $cpu_info3
        echo cpuinfo of $edgeaddress4 is $cpu_info4
        #echo cpuinfo of $cloudaddress is $cpu_info5

  			##########################################################################
  			#comapare the loadavarages and select the deivce that has the min loadavarage
  			echo -e
  			declare nodes_infos=($cpu_info1 $cpu_info2 $cpu_info3 $cpu_info4)

  			max=${nodes_infos[0]}
  			min=${nodes_infos[0]}
  			for i in "${nodes_infos[@]}";
  			do
  				(( $(echo "$i > $max" |bc -l) )) && max=$i
  				(( $(echo "$i < $min" |bc -l) )) && min=$i
  			done
  			echo maximum cpu is $max
  			echo minimum cpu is $min

  			#to find the index of device with maximum value
  			for i in "${!nodes_infos[@]}"; do
  			   if [[ "${nodes_infos[$i]}" = "${max}" ]]; then
  			     device1="${i}"
  			     echo index of maximum is $device1;
  			   fi
  			done

  			#To find the index of device with minimum value
  			for i in "${!nodes_infos[@]}"; do
  			   if [[ "${nodes_infos[$i]}" = "${min}" ]]; then
  			     device2="${i}"
  			       echo index of minimum is $device2;
  			   fi
  			done

  			##########################################################################
  			#edge_device = the deivce that has max MIPS value
  			edge_device=$device1

  		  case $edge_device in
  			'0')
  			   edgeaddress=$edgeaddress1
  			   edgeuser=$edgeuser1
  			   break;;
  			'1')
  			   edgeaddress=$edgeaddress2
  			   edgeuser=$edgeuser2
  			   break;;
  			'2')
  				 edgeaddress=$edgeaddress3
  				 edgeuser=$edgeuser3
  				 break;;
        '3')
           edgeaddress=$edgeaddress4
           edgeuser=$edgeuser4
           break;;

  			*)
  			   echo "Wrong input, try again";;
  		  esac
  		done
  	fi
  	echo ""
  	echo Workload will be offloaded to edge node $edgeaddress

}
################################################################################
function profiling_nodes {
  echo
  echo "Profiling edge nodes:"
  echo
  echo "Reading loadaverage of the available edge nodes:"
  cpu_usage1=$(ssh $edgeuser1@$edgeaddress1 cat /proc/loadavg | awk '{print $1}')
  cpu_usage2=$(ssh $edgeuser2@$edgeaddress2 cat /proc/loadavg | awk '{print $1}')
  cpu_usage3=$(ssh $edgeuser3@$edgeaddress3 cat /proc/loadavg | awk '{print $1}')
  cpu_usage4=$(ssh $edgeuser4@$edgeaddress4 cat /proc/loadavg | awk '{print $1}')

  echo loadavarage of $edgeaddress1 is $cpu_usage1
  echo loadavarage of $edgeaddress2 is $cpu_usage2
  echo loadavarage of $edgeaddress3 is $cpu_usage3
  echo loadavarage of $edgeaddress4 is $cpu_usage4
  echo

  echo "Reading Communication Latency to the available Edge Nodes:"
  node1_latency=$(ping -c 1 $edgeaddress1 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  node2_latency=$(ping -c 1 $edgeaddress2 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  node3_latency=$(ping -c 1 $edgeaddress3 | tail -1| awk '{print $4}' | cut -d '/' -f 2)
  node4_latency=$(ping -c 1 $edgeaddress4 | tail -1| awk '{print $4}' | cut -d '/' -f 2)

  echo Communciation Latency to $edgeaddress1 is $node1_latency ms
  echo Communciation Latency to $edgeaddress2 is $node2_latency ms
  echo Communciation Latency to $edgeaddress3 is $node3_latency ms
  echo Communciation Latency to $edgeaddress4 is $node4_latency ms
  echo

  echo "Reading Free Memory of available edge nodes"
  node1_mem=$(ssh $edgeuser1@$edgeaddress1 free --mega | grep Mem | awk '{print $4}')
  node2_mem=$(ssh $edgeuser2@$edgeaddress2 free --mega | grep Mem | awk '{print $4}')
  node3_mem=$(ssh $edgeuser3@$edgeaddress3 free --mega | grep Mem | awk '{print $4}')
  node4_mem=$(ssh $edgeuser4@$edgeaddress4 free --mega | grep Mem | awk '{print $4}')

  echo Free Memory of $edgeaddress1 is $node1_mem megabytes
  echo Free Memory of $edgeaddress2 is $node2_mem megabytes
  echo Free Memory of $edgeaddress3 is $node3_mem megabytes
  echo Free Memory of $edgeaddress4 is $node4_mem megabytes
  echo

  echo "Reading CPU specifications of available edge nodes:"
  cpu_info1=$(ssh $edgeuser1@$edgeaddress1 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  cpu_info2=$(ssh $edgeuser2@$edgeaddress2 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  cpu_info3=$(ssh $edgeuser3@$edgeaddress3 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)
  cpu_info4=$(ssh $edgeuser4@$edgeaddress4 grep bogomips -i /proc/cpuinfo | tail -1| awk '{print $3}' | cut -d '/' -f 2)

  echo cpuinfo of $edgeaddress1 is $cpu_info1
  echo cpuinfo of $edgeaddress2 is $cpu_info2
  echo cpuinfo of $edgeaddress3 is $cpu_info3
  echo cpuinfo of $edgeaddress4 is $cpu_info4
  echo
}
################################################################################
# utility function to manually determine the edge device based on deceion making alogrithm
function decision-making {
  echo "Decision Making:"
  python /Users/Yousef/Desktop/Dreich-master/DeFog/rm_mip.py
  echo Workload will be offloaded to edge node $edgeaddress4

  edgeaddress=$edgeaddress4
  edgeuser=$edgeuser4
}

################################################################################
# utility function to manually determine the edge device address (i.e. ipaddress) based on user input
function manual_selector {
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
	then
		while true; do
			echo ""
			echo -e "Please select edge node device:"
				echo "To choose Raspberry Pi 1, Enter 1"
				echo "To choose Raspberry Pi 2, Enter 2"
				echo "To choose Raspberry Pi 3, Enter 3"
        echo "To choose Raspberry Pi 4, Enter 4"
				echo ""
		  read -p "What device would you like to run:[1,2,3,4] " ANS
		  case $ANS in
			'1')
			   edgeaddress=$edgeaddress1
			   edgeuser=$edgeuser1
			   break;;
			'2')
			   edgeaddress=$edgeaddress2
			   edgeuser=$edgeuser2
			   break;;
			'3')
				 edgeaddress=$edgeaddress3
				 edgeuser=$edgeuser3
				 break;;
      '4')
   			edgeaddress=$edgeaddress4
   			edgeuser=$edgeuser4
   			break;;
			*)
			   echo "Wrong input, try again";;
		  esac
		done
	fi
	echo ""
	echo Workload will be offloaded to edge node $edgeaddress
}

################################################################################
# utility function to determine the platform actions to be perfomed based on user input
function actions_user_input {
while true; do
	echo "Actions:"
		echo "0. Run DeFog Platform Benchmarks"
		echo "1. Run DeFog, Sysbench & UnixBench Platform Benchmarks"
		echo "2. Run Network Benchmark"
		echo "3. Run I/O Benchmark"
		echo "4. Run Sysbench"
		echo "5. Run UnixBench"
		echo "6. Remove Docker Containers & DeFog Architecture"
		echo "7. None"
		echo ""
  read -p "What benchmark would you like to run:[0,1,2,3,4,5,6,7] " ANS
  case $ANS in
	'0')
       actions="-g"
	   break;;
    '1')
       actions="-a"
       break;;
    '2')
       actions="-d"
       break;;
	'3')
       actions="-f"
       break;;
	'4')
       actions="-s"
       break;;
    '5')
       actions="-u"
       break;;
	'6')
       actions="-x"
	   break;;
	'7')
       actions="-n"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform pipeline based on user input
function env_user_input {
while true; do
	echo ""
	echo "Environments:"
		echo "0. Cloud Only"
		echo "1. Edge Only"
		echo "2. Cloud & Edge"
		echo ""
  read -p "What environment would you like to benchmark: [0,1,2] " ANS
  case $ANS in
    '0')
       environment="-c"
       break;;
    '1')
       environment="-e"
       break;;
	  '2')
       environment="-b"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform applications to be benchmarked based on user input
function applications_user_input {
while true; do
	echo ""
	echo -e "Fog Applications:"
		echo "0. Yolo"
		echo "1. PocketSphinx"
		echo "2. Aeneas"
		echo "3. iPokeMon (build and run)"
		echo "4. iPokeMon (run benchmarks only)"
		echo "5. FogLAMP"
		echo "6. None"
		echo ""
  read -p "What Applications would you like to benchmark: [0,1,2,3,4,5,6] " ANS
  case $ANS in
    '0')
       applications="-y"
       break;;
    '1')
       applications="-p"
       break;;
	'2')
       applications="-j"
       break;;
	'3')
       applications="-i"
       break;;
	'4')
       applications="-k"
       break;;
	'5')
       applications="-l"
       break;;
	'6')
       applications="-m"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to determine the platform applications to be benchmarked
# on the cloud/edge pipeline based on user input
function applications_cloud_edge_user_input {
while true; do
	echo -e
	echo -e "Fog Applications:"
		echo ""
		echo "0. Yolo"
		echo "1. PocketSphinx"
		echo "2. Aeneas"
		echo "3. None"
		echo ""
  read -p "What Applications would you like to benchmark: [0,1,2,3] " ANS
  case $ANS in
    '0')
       applications="-y"
       break;;
    '1')
       applications="-p"
       break;;
	'2')
       applications="-j"
       break;;
	'3')
       applications="-m"
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_users_user_input {
while true; do
	echo -e
	echo -e "Please select the number of users to simulate:"
		echo ""
		echo "0. 1"
		echo "1. 2"
		echo "2. Default (5)"
		echo "3. 10"
		echo "4. 25"
		echo "5. 50"
		echo "6. 100"
		echo "7. 250"
		echo ""
  read -p "How many users/threads would you like to start: [0,1,2,3,4,5,6,7] " ANS
  case $ANS in
    '0')
       users=1
       break;;
    '1')
       users=2
       break;;
	'2')
       users=5
       break;;
	'3')
       users=10
       break;;
	'4')
       users=25
       break;;
	'5')
       users=50
       break;;
	'6')
       users=100
       break;;
	'7')
       users=250
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_duration_user_input {
while true; do
	echo -e
	echo -e "Please select the test duration in seconds:"
		echo ""
		echo "0. 60"
		echo "1. 120"
		echo "2. Default (300)"
		echo "3. 600"
		echo "4. 900"
		echo ""
  read -p "How long would you like to run the test: [0,1,2,3,4] " ANS
  case $ANS in
    '0')
       test_duration=60
       break;;
    '1')
       test_duration=120
       break;;
	'2')
       test_duration=300
       break;;
	'3')
       test_duration=600
       break;;
	'4')
       test_duration=900
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
function test_ramp_up_user_input {
while true; do
	echo -e
	echo -e "Please select the test ramp up period in seconds:"
		echo ""
		echo "0. Default (0)"
		echo "1. 10"
		echo "2. 30"
		echo "3. 60"
		echo "4. 120"
		echo ""
  read -p "How long would you like to ramp up the threads/users for: [0,1,2,3,4] " ANS
  case $ANS in
    '0')
       ramp_up=0
       break;;
    '1')
       ramp_up=10
       break;;
	'2')
       ramp_up=30
       break;;
	'3')
       ramp_up=60
       break;;
	'4')
       ramp_up=120
       break;;
    *)
       echo "Wrong input, try again";;
  esac
done
}

################################################################################
# utility function to print sepeartor/formatter line
function seperator {
echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
}

################################################################################
# print and display the ascii header
function display_ascii_header {

	echo "  ___      ___            _ ";
	echo " |   \ ___| __|__  __ _  (_)";
	echo " | |) / -_) _/ _ \/ _\` |  _ ";
	echo " |___/\___|_|\___/\__, | (_)";
	echo "                  |___/     ";
	echo ""
	echo -e "DeFog: " | tee $verbose_filename.txt
	echo -e "	Demystifying Fog Systems Interaction via Container based benchmarking." | tee $verbose_filename.txt
	echo -e "	Created by: Jonathan McChesney, student at Queen's University Belfast" | tee -a $verbose_filename.txt
	echo -e "	CSC4006 Final Year Research and Development Project" | tee -a $verbose_filename.txt
	echo -e "" | tee -a $verbose_filename.txt
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
	echo -e "" | tee -a $verbose_filename.txt
}

################################################################################
# create the various results file/filenames (data file, verbose data file, jmeter file, taurus file)
function create_result_files {
	verbose_filename=result
	metrics_verbose_filename=metrics
	jmeter_filename=jmeter
	taurus_filename=taurus
	filenumber=""

	cd results_Yousef    #changed by Yousef.. now all results are stored in the same file.cvs file
	if [[ -e $verbose_filename.txt ]] ; then
		i=0
		while [[ -e $verbose_filename-$i.txt ]] ; do
			let i++
		done
		filenumber=$i
		verbose_filename=$verbose_filename-$i
	fi
	if [[ -e $metrics_verbose_filename.txt ]] ; then
		i=0
		while [[ -e $metrics_verbose_filename-$i.txt ]] ; do
			let i++
		done
		filenumber=$i
		metrics_verbose_filename=$metrics_verbose_filename-$i
	fi
	if [[ -e $jmeter_filename.csv ]] ; then
		i=0
		while [[ -e $jmeter_filename-$i.csv ]] ; do
			let i++
		done
		filenumber=$i
		jmeter_filename=$jmeter_filename-$i
	fi
	if [[ -e $taurus_filename.csv ]] ; then
		i=0
		while [[ -e $taurus_filename-$i.csv ]] ; do
			let i++
		done
		filenumber=$i
		taurus_filename=$taurus_filename-$i
	fi
	cd ../
}

################################################################################
function setup_jmeter {

	if [ "$applications" == "-i" ] || [ "$applications" == "-k" ];
	then
		test_users_user_input
		test_duration_user_input
		test_ramp_up_user_input
	fi
}

################################################################################
function display_help {
	eval get_help=$1

	if [ "$get_help" == "-?" ] || [ "$applications" == "-h" ];
	then
		HELP
		exit 2
	fi
}

################################################################################
################################################################################
################################################################################
#########################################################################################################################
# CSC4006 - Research And Development Project
# Developed by: Jonathan McChesney (MEng Computer Games Development)
# Queen's University Belfast
#
# Component: defogexecute.sh
#
# Purpose: This script uses Secure Shell and Secure Copy Protocol to execute the actions.sh and applications.sh scripts
#			on the Cloud and Edge instances. This component also handles the calculation of metrics such as the return
#			trip time, real time factor and the full computation/communication latency time. Finally this component
#			also parses the return data and metrics and outputs the calculated metrics to the terminal and relevant
#			results files. This script passes the actions.sh and applications.sh to the Edge or Cloud instance.
#
#########################################################################################################################

# function to invoke Help and FAQ command line output
function executebenchmarkhelp {
		./defogexecute -?
}

#########################################################################################################################
# function to invoke the actions script on the cloud-edge pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters.
function benchmark_both_actions {
		# Use secure shell to navigate to the Cloud instance, using an identity file (awskey) username and cloud ec2 address.
		# The actions.sh script is supplied to the Cloud during the tunnelling porcess. This script is passed the actions and application inputs (sourced from defog.sh)
		echo -e "ssh into edge/cloud - cloud instance for actions and system benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./actions -z $actions $applications # environment variable is set to a different value for remote invocation
		echo -e "DONE - cloud ssh session"
		echo -e

		# Use secure shell to navigate to the Edge instance, using a username and edge node device address.
		# The actions.sh script is supplied to the Edge during the tunnelling porcess. This script is passed the actions and application inputs (sourced from defog.sh)
		echo -e "ssh into edge instance for actions and system benchmarks.."
		ssh $edgeuser@$edgeaddress ' sudo bash -s' -- < ./actions $environment $actions $applications
		echo -e "DONE - edge ssh session"
		echo -e
}

#########################################################################################################################
# function to invoke the application bash file on the cloud-edge pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters. The results are then transferred back from the edge as necessary.
function benchmark_both_applications {
		echo -e "ssh into edge/cloud - cloud instance for applications benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./applications -z $actions $applications
		echo -e "DONE - cloud ssh session"
		echo -e

		echo -e "ssh into edge/cloud instance for applications benchmarks.."
		ssh $edgeuser@$edgeaddress ' sudo bash -s' -- < ./applications $environment $actions $applications
		echo -e "DONE - edge ssh session"
		echo -e

		# calculate the time taken to transfer data (i.e. resutlts and data files from the edge to the local user device
		local start=$(gdate +%s.%N) #date +%s
		local transfer_cloud=$(scp -v $edgeuser@$edgeaddress:~/defog/results/* ./ 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )

		# set the transfer time, bytes transfered down and bytes per second down and set to the relevant metric index
		metricsValues[3]=$runtime
		metricsValues[8]=${newarr1[1]}
		metricsValues[11]=$(bc <<< "scale=10;${metricsValues[8]}/${metricsValues[3]}")

		# rename verbose results file, remove old file
		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		rm cloudresult.txt 2>/dev/null

		# read in results data file, save to array, remove old file
		read -a newarr < arrresult.txt
		rm arrresult.txt 2>/dev/null

		# print and save data to file
		echo -e Total bytes transferred from the edge: ${metricsValues[8]} bytes | tee -a $verbose_filename.txt
		echo Transfer both pipeline edge application results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo Transfer rate from the edge: ${metricsValues[11]} bytes per second | tee -a $verbose_filename.txt

		# invoke the set_returned_application_metrics function to set data metrics to global array
		set_returned_application_metrics

		# calculate the bytes per second down from the cloud to the edge and save to array
		metricsValues[12]=$(bc <<< "scale=10;${metricsValues[9]}/${metricsValues[13]}")
		echo "" | tee -a $verbose_filename.txt
}

#########################################################################################################################
# function to invoke the actions script on the edge only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters.
function benchmark_edge_actions {
		echo -e "ssh into edge instance for actions and system benchmarks.."
		ssh $edgeuser@$edgeaddress ' sudo bash -s' -- < ./actions $environment $actions $applications
		echo -e "DONE - edge ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		scp $edgeuser@$edgeaddress:~/defog/results/* ./
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )

		cat edgeresult.txt >> $verbose_filename.txt 2>/dev/null
		rm edgeresult.txt 2>/dev/null

		echo -e Transfer edge action results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# function to invoke the application bash file on the edge only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters. The results are then transferred back from the edge as necessary.
function benchmark_edge_applications {

    # invoke the secure copy protocol asset function
    echo -e "Sending asset at path: " $asset "to application..."
    scp_asset
    echo -e "DONE - transferring asset payload to destination"

		echo -e "ssh into edge instance for application benchmarks.."
		ssh	$edgeuser@$edgeaddress ' sudo bash -s' -- < ./applications $environment $actions $applications
		echo -e "DONE - edge ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		local transfer_cloud=$(scp -v $edgeuser@$edgeaddress:~/defog/results/* ./ 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )
		metricsValues[3]=$runtime
		metricsValues[8]=${newarr1[1]}
		metricsValues[11]=$(bc <<< "scale=10;${metricsValues[8]}/${metricsValues[3]}")

		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		rm cloudresult.txt 2>/dev/null

		read -a newarr < arrresult.txt
		rm arrresult.txt 2>/dev/null

		echo -e Total bytes transferred from the edge: ${metricsValues[8]} bytes | tee -a $verbose_filename.txt
		echo Transfer edge application results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo Transfer rate from the edge: ${metricsValues[11]} bytes per second | tee -a $verbose_filename.txt

		set_returned_application_metrics

		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# function to invoke the actions script on the cloud only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters.
function benchmark_cloud_actions {
		echo -e "ssh into cloud instance for actions and system benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./actions $environment $actions $applications
		echo -e "DONE - cloud ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		scp -i $awskey $clouduser@$cloudaddress:~/defog/results/* ./
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )

		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		rm cloudresult.txt 2>/dev/null

		echo -e Transfer cloud action results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# function to invoke the application bash file on the cloud only pipeline by sshing into both the cloud and edge and calling the actions bash script
# passing the relevant variables as file parameters. The results are then transferred back from the edge as necessary.
function benchmark_cloud_applications {

    # invoke the secure copy protocol asset function
    echo -e "Sending asset at path: " $asset "to application..."
    scp_asset
    echo -e "DONE - transferring asset payload to destination"

		echo -e "ssh into cloud instance for application benchmarks.."
		ssh -i $awskey $clouduser@$cloudaddress ' sudo bash -s' -- < ./applications $environment $actions $applications
		echo -e "DONE - cloud ssh session"
		echo -e

		local start=$(gdate +%s.%N)
		local transfer_cloud=$(scp -v -i $awskey $clouduser@$cloudaddress:~/defog/results/* ./ 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
		local end=$(gdate +%s.%N)
		local runtime=$( echo "$end - $start" | bc -l )
		metricsValues[3]=$runtime
		metricsValues[8]=${newarr1[1]}
		metricsValues[11]=$(bc <<< "scale=10;${metricsValues[8]}/${metricsValues[3]}")

		rm returnedasset.* 2>/dev/null

		cat cloudresult.txt >> $verbose_filename.txt 2>/dev/null
		rm cloudresult.txt 2>/dev/null

		read -a newarr < arrresult.txt
		rm arrresult.txt 2>/dev/null

		echo -e Total bytes transferred from the cloud: ${metricsValues[8]} bytes | tee -a $verbose_filename.txt
		echo Transfer cloud application results to edge device: completed in $runtime secs | tee -a $verbose_filename.txt
		echo Transfer rate from the cloud: ${metricsValues[11]} bytes per second | tee -a $verbose_filename.txt

		set_returned_application_metrics

		echo "" | tee -a $verbose_filename.txt

}

#########################################################################################################################
# calculate the cost of running the benchmarks on the cloud, using AWS pricing strategy
function calc_cloud_cost {

	# initialise local variables: hourly cost of computation on AWS, convertor scalar value, cost per second and compute time.
	local awshrcost=0.016
	local convert=3600
	local awsseccost=$(bc <<< "scale=10;$awshrcost/$convert") # scale=10 sets the number of decimal places to 10
	local minruntime=60
	local computetime=${metricsValues[1]}

	# deterime the cost of running on AWS using the bc utility package
	local cost=$(bc <<< "$computetime*$awsseccost")

	# update the metric array
	metricsValues[6]=$cost

	# output the results to file and the terminal using tee
	echo -e "Cloud cost for application computation (£0.016 per hour)": £$cost | tee -a $verbose_filename.txt

}

#########################################################################################################################
# Estimage the cost of running the benchmarks on the edge using a cheaper AWS pricing strategy (50% of AWS cost)
function calc_edge_cost {

	# initialise the local variables - Estimated cost based upon AWS pricing strategy
	local edgehrcost=0.008
	local convert=3600
	local edgeseccost=$(bc <<< "scale=10;$edgehrcost/$convert") # scale=10 sets the number of decimal places to 10
	local computetime=${metricsValues[1]}

	# deterime the cost of running on AWS using the bc utility package
	local cost=$(bc <<< "$computetime*$edgeseccost")

	# update the metric array
	metricsValues[6]=$cost

	# output the results to file and the terminal using tee
	echo -e "Edge cost for application computation (estimated £0.008 per hour)": £$cost | tee -a $verbose_filename.txt

}

#########################################################################################################################
# calculate the return trip time and communication latency metrics
function calc_rtt {

	local T1=${metricsValues[0]}
	local E=${metricsValues[1]}
	local T3=${metricsValues[3]}

	if  [ "${metricsValues[13]}" == "NA" ];
	then
		local T4=0
	else
		local T4=${metricsValues[13]}
	fi

	local cl=$(bc <<< "$T1+$T3") # communication latency
	local rtt=$(bc <<< "$T1+$T3+$E") # round trip time
	local fcl=$(bc <<< "$T1+$T3+$T4") # communication latency
	local frtt=$(bc <<< "$T1+$T3+$E+$T4") # round trip time

	metricsValues[4]=$rtt # time to transfer data to and from cloud/edge as well as computation time
	metricsValues[14]=$cl # time to transfer data to and from cloud/edge
	metricsValues[15]=$frtt # time to transfer data to and from cloud/edge as well as computation time
	metricsValues[16]=$fcl # time to transfer data to and from cloud/edge

	echo -e Round Trip Time: $rtt secs | tee -a $verbose_filename.txt

}

#########################################################################################################################
# calculate real time factor for audio applications (computational time / length of audio file in seconds)
function calc_rtf {
	local computation=${newarr[1]}
	local length=${newarr[5]}
	local rtf=$(bc <<< "scale=10;$computation/$length")

	metricsValues[5]=$rtf

	echo Real Time Factor: $rtf secs | tee -a $verbose_filename.txt
}

#########################################################################################################################
# iterate over metrics returned from the edge or cloud, set them to local array
function set_returned_application_metrics {
	local mets=${#metricsValues[@]}
	local count=1

	if [ "${newarr[10]}" != "NA" ];
	then
		metricsValues[13]=${newarr[10]} # set time taken to transfer data from the cloud to the edge
	fi

	for (( i=0; i<=$(( $mets -1 )); i++ ))
	do
		((count++))

		if [ "${metricsValues[$i]}" == "NA" ] && [ "${newarr[$i]}" != "NA" ] && [ "${newarr[$i]}" ];
		then
			metricsValues[$i]=${newarr[$i]} # set retured data to local array
		fi
	done

}

#########################################################################################################################
# utility function to update the current pipeline text based on the input sourced from the defog.sh script
function set_pipeline {
		# initialise to default value
		pipeline="NA"

		# set the pipeline variable name to the current pipeline/platform selected, sourced from defog.sh
		if [ "$environment" == "-c" ]; then pipeline="Cloud-Only";
		elif [ "$environment" == "-e" ]; then pipeline="Edge-Only";
		elif [ "$environment" == "-b" ]; then pipeline="Cloud/Edge";
		fi
}

#########################################################################################################################
# invoke the relevant application benchmark utility function
function benchmark_applications {

		set_pipeline

		# print application header to verbose file and invoke application benchmarks
		if [ "$applications" == "-y" ];
		then
			echo YOLO Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_fog_app "arrPics" "./assets/yolo-assets/yoloimage.jpg" "./assets/yolo-assets/*.jpg" "YOLO"

		elif [ "$applications" == "-p" ];
		then
			echo Pocket Sphinx Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_fog_app "arrWavs" "./assets/psphinx-assets/psphinx.wav" "./assets/psphinx-assets/*.wav" "PocketSphinx"

		elif [ "$applications" == "-j" ];
		then
			echo Aeneas Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_aeneas

		elif [ "$applications" == "-i" ];
		then
			echo iPokeMon Benchmarks: | tee -a $verbose_filename.txt
			seperator
			start_ipokemon_server
			benchmark_ipokemon

		elif [ "$applications" == "-k" ];
		then
			echo iPokeMon Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_ipokemon

		elif [ "$applications" == "-l" ];
		then
			echo FogLAMP Benchmarks: | tee -a $verbose_filename.txt
			seperator
			benchmark_fog_app "arrCurlCommands" "./assets/foglamp-assets/foglampcurlcommand.sh" "./assets/foglamp-assets/*.sh" "FogLAMP"
		fi
}

#########################################################################################################################
# benchmark iPokemon server using a jmx file to simulate user behaviour
function benchmark_ipokemon {
	# navigate to jmeter bin folder
	cd jmeter/bin

	# initialise the local asset variables
	local ipokemon_jmx=../../assets/ipokemon-assets/iPokemon.jmx
	local host=''

	if [ "$environment" == "-c" ];
	then
		host=$cloudpublicip # if cloud
	else
		host=$edgeaddress # if edge
	fi

	# run jmeter using user defined variables (automation of jsx file - allows execution on the edge or cloud)
	echo "Running JMeter..."
	./jmeter -n -t $ipokemon_jmx -JHOST=$host -JDuration=$test_duration -JThreads=$users -JRamp=$ramp_up -l testresults.csv

	# run tautus using user defined variables (automation of jmeter jsx file) and using reporting.yaml as a parameter
	echo "Running Taurus..."
	bzt $ipokemon_jmx -o modules.jmeter.properties.HOST=$host -o modules.jmeter.properties.Duration=$test_duration -o modules.jmeter.properties.Threads=$users -o modules.jmeter.properties.Ramp=$ramp_up reporting.yaml

	# move and rename test data files to the results file, redirect output using 2>/dev/null
	mv testresults.csv ../../results/$jmeter_filename.csv 2>/dev/null
	mv taurusreport.csv ../../results/$taurus_filename.csv 2>/dev/null
	mv taurusreport.xml ../../results/$taurus_filename.xml 2>/dev/null

	# navigate to defog folder
	cd ../../
}

#########################################################################################################################
# setup and start the iPokeMon server
function start_ipokemon_server {
		# determine the platform/pipeline secure shell tunnel (ssh) into, and enter the iPokeMon docker container (use ctrl p & ctrl q to detach the container)
		if [ "$environment" == "-c" ] || [ "$environment" == "-b" ];
		then
			ssh -i $awskey $clouduser@$cloudaddress -t "cd defog/ipokemonbuild/iPokeMon/docker && sudo -sH && . enter.sh; bash"
		fi
		if [ "$environment" == "-e" ] || [ "$environment" == "-b" ];
		then
			ssh $edgeuser@$edgeaddress -t "cd defog/ipokemonbuild/iPokeMon/docker && sudo -sH && . enter.sh; bash"
		fi
}

#########################################################################################################################
# determine the pipeline/platform to benchmark the applications on, invoke the calculation of real time trip and real time factor variables
function benchmark_application {
		echo -e
		if [ "$environment" == "-c" ]; # cloud only
		then
			benchmark_cloud_applications
			calc_rtt
			if [ "${metricsValues[5]}" != "NA" ];
			then
				calc_rtf
			fi
			calc_cloud_cost
		fi
		if [ "$environment" == "-e" ]; # edge only
		then
			benchmark_edge_applications
			calc_rtt
			if [ "${metricsValues[5]}" != "NA" ];
			then
				calc_rtf
			fi
			calc_edge_cost
		fi
		if [ "$environment" == "-b" ]; # cloud/edge
		then
			benchmark_both_applications
			calc_rtt
			if [ "${metricsValues[5]}" != "NA" ];
			then
				calc_rtf
			fi
			calc_edge_cost
		fi
		echo -e
		echo -e "DeFog Metrics:"
		echo -e ${metricsValues[@]} | tee -a $metrics_verbose_filename.txt
}

#########################################################################################################################
# benchmark fog application - accepts asset array name, asset name, asset path and application name as parameters.
function benchmark_fog_app {

	# evaluate paramaters and initialise variables # benchmark_fog_app "arrPics" "./assets/yolo-assets/yoloimage.jpg" "./assets/yolo-assets/*.jpg" "YOLO"
	eval array_name="$1"                          # arrPics
	eval new_asset_name="$2"                      # ./assets/yolo-assets/yoloimage.jpg
	eval asset_path="$3"                          # ./assets/yolo-assets/*.jpg
	eval application_name="$4"                    # YOLO

	# declare asset array, asset name and counter
	declare -a $array_name
	newassetname=$new_asset_name
	local count=1

	# iterate over all assets in an asset folder
	for file in $asset_path
	do
		# reset/create the metric array
		create_metric_array

		# Output to the terminal and results file using tee
		echo -e "" | tee -a $verbose_filename.txt
		echo $application_name Benchmark Run $count: | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

		# update array and asset variables for the current iteration
		array_name=("${assets_name[@]}" "$file")
		asset=$array_name

    # select edge node based on different functions
    #manual_selector                              # to select edge node manually
    random_selector                               # to select edge node randomly
    #nodes_loadavg                                # to select edge node min loadavg
    #nodes_latency                                # to select edge node min latecny
    #nodes_memory                                 # to select edge node max memory
    #nodes_specification
    #decision-making                             # to select edge node based on decision-making function

    #edgeaddress=$edgeaddress  #some function to retun Ip address of the device
	  #edgeuser=$edgeuser

    #metricsValues[19]=$edgeaddress #added by Yousef to read ip address of the edge device
    if [ "$environment" == "-c" ]; then metricsValues[19]=$cloudaddress; #added by Yousef
    elif [ "$environment" == "-e" ]; then metricsValues[19]=$edgeaddress;  #added by Yousef
    fi
		# Update the pipeline and application metric values
		metricsValues[17]=$pipeline
		metricsValues[18]=$application_name

    benchmark_edge_actions
    transfer_config "1"

		# invoke the secure copy protocol asset function
		#echo -e "Sending asset at path: " $asset "to application..."
		#scp_asset
		#echo -e "DONE - transferring asset payload to destination"

		# invoke the benchmark_application function
		benchmark_application

		# increment counter
		((count++))

	done
}

#########################################################################################################################
function benchmark_aeneas {

  # select edge node based on different functions
  #manual_selector                              # to select edge node manually
  random_selector                               # to select edge node randomly
  #nodes_loadavg                                # to select edge node min loadavg
  #nodes_latency                                # to select edge node min latecny
  #nodes_memory                                 # to select edge node max memory
  #nodes_specification
  #decision-making                             # to select edge node based on decision-making function
  #edgeaddress=$edgeaddress  #some function to retun Ip address of the device
  #edgeuser=$edgeuser

  #metricsValues[19]=$edgeaddress #added by Yousef to read ip address of the edge device
  if [ "$environment" == "-c" ]; then metricsValues[19]=$cloudaddress; #added by Yousef
  elif [ "$environment" == "-e" ]; then metricsValues[19]=$edgeaddress;  #added by Yousef
  fi
  # Update the pipeline and application metric values
  metricsValues[17]=$pipeline
  metricsValues[18]=$application_name

  benchmark_edge_actions
  transfer_config "1"

	declare -a arrAudios

	for file1 in ./assets/aeneas-assets/audio/*.mp3
	do
		arrAudios=("${arrAudios[@]}" "$file1")
	done

	declare -a arrTexts

	for file2 in ./assets/aeneas-assets/text/*.xhtml
	do
		local arrTexts=("${arrTexts[@]}" "$file2")
	done

	total=${#arrAudios[@]}

	local count=1

	for (( j=0; j<=$(( $total -1 )); j++ ))
	do

		multiassets="true"
		create_metric_array

		metricsValues[17]=$pipeline
		metricsValues[18]="Aeneas"
		metricsValues[19]=$edgeaddress #added by Yousef to read ip address of the edge device

		echo -e "" | tee -a $verbose_filename.txt
		echo Aeneas Benchmark Run $count: | tee -a $verbose_filename.txt
		echo "" | tee -a $verbose_filename.txt

		asset=${arrAudios[$j]}
		newassetname=./assets/aeneas-assets/aeneasaudio.mp3

		echo "Sending asset at path: " $asset "to application..."
		scp_asset
		echo "DONE"

		local oldT1=${metricsValues[0]}
		local oldbu1=${metricsValues[7]}

		metricsValues[0]=$oldT1
		metricsValues[7]=$oldbu1

		asset=${arrTexts[$j]}
		newassetname=./assets/aeneas-assets/aeneastext.xhtml

		if [ "$environment" != "-b" ];
		then
			echo -e "Sending asset at path: " $asset "to application..."
			scp_asset
			echo "DONE"
		fi

		if [ "$environment" == "-b" ];
		then
			local shortasset="${asset##*/}"
			echo $shortasset > ./aeneas.txt

			asset=./aeneas.txt
			newassetname=./aeneas.txt

			echo -e "Sending asset at path: " $asset "to application..."
			scp_asset
			echo "DONE"
		fi

		benchmark_application

		((count++))

	done

}

#########################################################################################################################
# instantiate or reset metric labels and values to default values
function create_metric_array {
	declare -g metricsLabels=('T1' 'ET' 'T2' 'T3' 'RTT' 'RTF' 'Cost' 'BytesUp1' 'BytesDown1' 'BytesDown2' 'BytesPerSecUp1' 'BytesPerSecDown1' 'BytesPerSecDown2' 'T4' 'CL' 'FRTT' 'FCL' 'Pipeline' 'Application' 'Device')
	declare -g metricsValues=('NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA' 'NA')
}

#########################################################################################################################
# secure copy/transfer data/assets to destination platform
function scp_asset {
	TIMEFORMAT=%R # set time format
	cp $asset $newassetname       #copy sourcefile destinationfile
	local start=$(gdate +%s.%N) # start timer to calculat ethe time it takes to transfer data

	# transfer data to the cloud and set array metrics to local variable
	if [ "$environment" == "-c" ]; # cloud only
	then
		local transfer_cloud=$(scp -v -i $awskey $newassetname $clouduser@$cloudaddress:~/defog/assets 2>&1 | grep "Transferred")
		local newval=${transfer_cloud//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
	fi

	# transfer data to the edge and set array metrics to local variable
	if [ "$environment" == "-e" ] || [ "$environment" == "-b" ]; # edge only or cloud/edge
	then
		local transfer_edge=$(scp -v $newassetname $edgeuser@$edgeaddress:~/defog/assets 2>&1 | grep "Transferred")
		local newval=${transfer_edge//[!0-9\\ \\.]/}
		newarr1=(`echo ${newval}`);
	fi

	# determine the time taken to transfer data
	local end=$(gdate +%s.%N)
	local runtime=$( echo "$end - $start" | bc -l )

	# if running an application that sends multiple assets - sum the bytes sent and time taken to transfer the assets
	if [ "$multiassets" == "true" ] && [ "${metricsValues[0]}" != "NA" ];
	then
		metricsValues[0]=$(bc <<< "${metricsValues[0]}+$runtime")
		metricsValues[7]=$(bc <<< "${metricsValues[7]}+${newarr1[0]}")
		local bytesUpVar=$(bc <<< "scale=10;${metricsValues[7]}/${metricsValues[0]}")
		metricsValues[10]=$(bc <<< "$bytesUpVar")
	else
		metricsValues[0]=$runtime
		metricsValues[7]=${newarr1[0]}
		metricsValues[10]=$(bc <<< "scale=10;${metricsValues[7]}/${metricsValues[0]}")
	fi

	# remove duplicate asset
	rm $newassetname 2>/dev/null

}

#########################################################################################################################
# transfer the configuration file securely to the cloud or the edge using secure copy protocol. The destination platform is passed in as a paramater. Redirect the console output using 2>&1.
function transfer_config {
	# evaluate the destination platform id parameter
	eval config_destination="$1"

	if [ "$config_destination" == "1" ] || [ "$config_destination" == "2" ]; then # if edge or cloud/edge
		echo -e "Transferring configuration files to the Edge:"
			#scp $configslocation $edgeuser@$edgeaddress:~/defog/configs > /dev/null 2>&1
			scp $configslocation $edgeuser@$edgeaddress:~/defog/configs 2>&1
	fi
	if [ "$config_destination" == "0" ] || [ "$config_destination" == "2" ]; then # if cloud or cloud/edge
		echo -e "Transferring configuration files to the Cloud:"
			scp -i $awskey $configslocation $clouduser@$cloudaddress:~/defog/configs 2>&1
	fi
	echo -e "DONE - Transferring configuration files"
	echo -e
}

#########################################################################################################################
# utility function to print verbose sepeartor/formatter line to file using tee
function seperator {
	echo -e "*****************************************************************************" | tee -a $verbose_filename.txt
}

################################################################################
################################################################################
################################################################################
################################################################################

#The appalication start here:
create_result_files
#profiling_nodes
#display_ascii_header
#display_help $1
applications_user_input  # choose application first then choose the deployment environment (Cloud / edge)
env_user_input
if [ "$environment" == "-c" ]; # cloud only
then
  echo ""
  echo -e "Cloud Only Benchmarks: " | tee -a $verbose_filename.txt
  seperator
  echo "" | tee -a $verbose_filename.txt
  setup_jmeter
fi

if [ "$environment" == "-e" ]; # edge only #some changes on edge environment by Yousef
then
  echo ""
  echo -e "Edge Only Benchmarks: " | tee -a $verbose_filename.txt
  seperator
  echo "" | tee -a $verbose_filename.txt
  #edgeaddress_selector_modified  # added by Yousef # this should be seleceted dynmanically
  setup_jmeter
fi

if [ "$environment" == "-b" ]; # cloud/edge
then
  echo ""
  echo -e "Edge/Cloud Benchmarks: " | tee -a $verbose_filename.txt
  seperator
  echo "" | tee -a $verbose_filename.txt
  manual_selector
  actions="-n"
  applications_cloud_edge_user_input
fi

echo -e
(
    export actions
    export environment
    export applications
    export users
    export ramp_up
    export test_duration
    export filenumber
    export verbose_filename
    export metrics_verbose_filename
    export jmeter_filename
    export taurus_filename
    export cloudaddress
    export clouduser
    export edgeaddress
    export edgeaddress1
    export edgeaddress2
    export edgeuser
    export edgeuser1
    export edgeuser2
    export awskey
    export cloudpublicip
    export configslocation
    export configfilelocation

    #(source ./defogexecute)  # I merge defog file and defogexecute

)
################################################################################
################################################################################
################################################################################
# main functionality - invoke the create_metric_array function, output the metric labels to the result file. Determine the pipeline to run based on input sourced from the defog.sh script.
# transfer the config file to the Edge r Cloud and run the action or application functions. Cat and command line utility tr -s is used to parse and format the results data to a csv output file.
# The output files are then moved to the results folder

function main {

	# invoke the creation of the metric array
	create_metric_array

	# output the lavels to the results file
	echo ${metricsLabels[@]} >> $metrics_verbose_filename.txt

	# handle the pipeline specific actions/application benchmarks
	if [ "$environment" == "-c" ]; # cloud only
	then
		benchmark_cloud_actions
		transfer_config "0"
		benchmark_applications
	fi

	if [ "$environment" == "-e" ]; # edge only
	then
		#benchmark_edge_actions
		#transfer_config "1"
		benchmark_applications
	fi

	if [ "$environment" == "-b" ]; # cloud/edge
	then
		benchmark_both_actions
		transfer_config "2"
		benchmark_applications
	fi

	# parase and format the captured metric data and output to a csv file. Using the correct naming convention variable. The output is redirected to remove unnecessary terminal output
	cat $metrics_verbose_filename.txt | tr -s '[:blank:]' ',' > $metrics_verbose_filename.csv 2>/dev/null

	# move the results files to the results output and redirect terminal std:: output
	mv $verbose_filename.txt results/ 2>/dev/null
	mv $metrics_verbose_filename.txt results/ 2>/dev/null
	mv $metrics_verbose_filename.csv results/ 2>/dev/null
	rm results.txt 2>/dev/null
}

main

################################################################################
################################################################################
################################################################################
# expect user input for displaying helphelp
while getopts :h: opt; do
    case "$opt" in
        h)
            HELP
            ;;
        ?)
            HELP
            ;;
    esac
done
